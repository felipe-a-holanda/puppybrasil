#!/bin/sh
#Badly hacked by Barry Kauler 2005,2006,2007 for Puppy Linux, www.puppylinux.com
#v423 kirk: add ext4 support.
#v424 BK: bugfixes. fix accidental wiping partition!

#BK...
export XDIALOG_HIGH_DIALOG_COMPAT=true
#all incidents of 'dialog' replaced by 'Xdialog' below...
BKPASSED_DEVICE="$1"

#BK 1.0.6... needs C locale to work...
export LANG=C

# Copyright 2004 Kent Robotti <robotti@godmail.com> 8-31-2004
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# grubconfig is based on liloconfig by Patrick Volkerding fron the
# Slackware Linux distribution.
#
# Copyright 1994, 1998, 1999  Patrick Volkerding, Moorhead, Minnesota USA
# Copyright 2002, 2003, 2004  Slackware Linux, Inc, Concord, CA
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

TMP=/tmp/grubconfig
BOOT_TMP=/tmp/boot
CONSOLETYPE=standard
CONSOLENUM=normal

#v424 if $BOOT_TMP has a partititon mounted on it, it gets wiped!!!!
#this bug occurs a couple of times this script.
test_boot_tmp_func() {
 btPATTERN=" ${BOOT_TMP} "
 if [ "`mount | grep "$btPATTERN"`" != "" ];then
  sync
  umount $BOOT_TMP
 fi
 if [ "`mount | grep "$btPATTERN"`" != "" ];then
  btPART="`mount | grep "$btPATTERN" | cut -f 1 -d ' '`"
  xmessage -bg red -center "ERROR: could not unmount partition ${btPART} mounted on ${BOOT_TMP}"
  exit
 fi
}

rm -rf $TMP
#v424 had situation previous aborted grubconfig left partition mounted,
#then when reran script, it wiped entire partition...
test_boot_tmp_func #v424
rm -rf $BOOT_TMP
mkdir -p $TMP $BOOT_TMP

PATH=$PATH:/bin:/usr/bin:/sbin:/usr/sbin

# Menu to check if we want to use VESA framebuffer support:
use_framebuffer() {
CONSOLETYPE=standard
CONSOLENUM=normal
if grep -q "29 fb" /proc/devices ; then
  Xdialog --title "CONFIGURE GRUB TO USE FRAME BUFFER CONSOLE?" \
  --menu "Looking at /proc/devices, it seems your kernel has support for \
the Linux frame buffer console.  If we enable this, it \
will allow more rows and columns of text on the screen and give you a cool \
penguin logo at boot time.  However, the frame buffer text console is \
slower than a standard text console.  In addition, not every video card \
or monitor supports all of these video modes.  Would you like to use the \
frame buffer console, or the standard Linux console?" 0 0 0 \
  "standard" "Use the standard Linux console (the safe choice)" \
  "640x480x256" "Frame buffer console, 640x480x256" \
  "800x600x256" "Frame buffer console, 800x600x256" \
  "1024x768x256" "Frame buffer console, 1024x768x256" \
  "640x480x32k" "Frame buffer console, 640x480x32k" \
  "800x600x32k" "Frame buffer console, 800x600x32k" \
  "1024x768x32k" "Frame buffer console, 1024x768x32k" \
  "640x480x64k" "Frame buffer console, 640x480x64k" \
  "800x600x64k" "Frame buffer console, 800x600x64k" \
  "1024x768x64k" "Frame buffer console, 1024x768x64k" \
  2> $TMP/reply
  if [ ! $? = 0 ]; then
    chroot_umount
    exit
  fi
# Frame buffer modes above 1024x768 look terrible except
# on LCD panels, and 32 bit color is slow.  Since we don't
# even need to run a framebuffer console to run framebuffer
# X anymore, these modes aren't of much real use.
#  "1280x1024x256" "Frame buffer console, 1280x1024x256" \
#  "1600x1200x256" "Frame buffer console, 1600x1200x256" \
#  "1280x1024x32k" "Frame buffer console, 1280x1024x32k" \
#  "1600x1200x32k" "Frame buffer console, 1600x1200x32k" \
#  "1280x1024x64k" "Frame buffer console, 1280x1024x64k" \
#  "1600x1200x64k" "Frame buffer console, 1600x1200x64k" \
#  "640x480x16m" "Frame buffer console, 640x480x16.8m" \
#  "800x600x16m" "Frame buffer console, 800x600x16.8m" \
#  "1024x768x16m" "Frame buffer console, 1024x768x16.8m" \
#  "1280x1024x16m" "Frame buffer console, 1280x1024x16.8m" \
#  "1600x1200x16m" "Frame buffer console, 1600x1200x16.8m"
  CONSOLETYPE="`cat $TMP/reply`"
  if [ "$CONSOLETYPE" = "standard" ]; then
    CONSOLENUM=normal
  elif [ "$CONSOLETYPE" = "1600x1200x16m" ]; then
    CONSOLENUM=799
  elif [ "$CONSOLETYPE" = "1600x1200x64k" ]; then
    CONSOLENUM=798
  elif [ "$CONSOLETYPE" = "1600x1200x32k" ]; then
    CONSOLENUM=797
  elif [ "$CONSOLETYPE" = "1600x1200x256" ]; then
    CONSOLENUM=796
  elif [ "$CONSOLETYPE" = "1280x1024x16m" ]; then
    CONSOLENUM=795
  elif [ "$CONSOLETYPE" = "1280x1024x64k" ]; then
    CONSOLENUM=794
  elif [ "$CONSOLETYPE" = "1280x1024x32k" ]; then
    CONSOLENUM=793
  elif [ "$CONSOLETYPE" = "1280x1024x256" ]; then
    CONSOLENUM=775
  elif [ "$CONSOLETYPE" = "1024x768x16m" ]; then
    CONSOLENUM=792
  elif [ "$CONSOLETYPE" = "1024x768x64k" ]; then
    CONSOLENUM=791
  elif [ "$CONSOLETYPE" = "1024x768x32k" ]; then
    CONSOLENUM=790
  elif [ "$CONSOLETYPE" = "1024x768x256" ]; then
    CONSOLENUM=773
  elif [ "$CONSOLETYPE" = "800x600x16m" ]; then
    CONSOLENUM=789
  elif [ "$CONSOLETYPE" = "800x600x64k" ]; then
    CONSOLENUM=788
  elif [ "$CONSOLETYPE" = "800x600x32k" ]; then
    CONSOLENUM=787
  elif [ "$CONSOLETYPE" = "800x600x256" ]; then
    CONSOLENUM=771
  elif [ "$CONSOLETYPE" = "640x480x16m" ]; then
    CONSOLENUM=786
  elif [ "$CONSOLETYPE" = "640x480x64k" ]; then
    CONSOLENUM=785
  elif [ "$CONSOLETYPE" = "640x480x32k" ]; then
    CONSOLENUM=784
  elif [ "$CONSOLETYPE" = "640x480x256" ]; then
    CONSOLENUM=769
  fi
fi
}

chroot_umount() {
if [ "$CHROOT" = "YES" ]; then
  umount /proc
fi
}

create_devices() {
      fdisk -l >$TMP/DEV 2>$TMP/null
}

hd_mbr() {
 mbr_dev="`grep "^Disk /dev/" $TMP/DEV | head -n 1 | cut -d ' ' -f 2 | cut -b 1-8`"
 mbr_dev2="`grep "^Disk /dev/" $TMP/DEV | tail -n 1 | cut -d ' ' -f 2 | cut -b 1-8`"
 if [ -z $mbr_dev ]; then
  kill $INFOPID 2>/dev/null
  $DIALOG --title "Grubconfig: ERROR" --msgbox \
  "I can't find a device to install GRUB to!" 0 0 #5 60
  umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
  rm -rf $TMP
  chroot_umount
  exit
 elif [ $mbr_dev2 = $mbr_dev ]; then
  mbr_grub_dev=hd0
  #BK if ! probe $mbr_dev; then
  if [ "`probepart | grep "$mbr_dev"`" = "" ];then
   kill $INFOPID 2>/dev/null
   $DIALOG --title "Grubconfig: ERROR" --msgbox \
   "I can't find the device '$mbr_dev', so I can't install GRUB!" 0 0 #5 68
   umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
   rm -rf $TMP
   chroot_umount
   exit
  fi
 else
  while :
  do
   cat << EOF >$TMP/tmpmsg
Puppy users: If running grubconfig from Universal Installer,
             leave the box empty, just click OK button.

Usually GRUB is installed to the MBR of the primary
hard drive, in your case '$mbr_dev'.

If you have more than one hard drive, and want GRUB installed
to the MBR of another hard drive, put the device below or
leave the box blank for '$mbr_dev'.
EOF
 
   #    $DIALOG --title "HARD DRIVE MBR" --inputbox "`cat $TMP/tmpmsg`" 0 68 2> $TMP/mbr_dev
   kill $INFOPID 2>/dev/null
   $DIALOG --title "Grubconfig: HARD DRIVE MBR" --inputbox "`cat $TMP/tmpmsg`" 0 0 2> $TMP/mbr_dev
   if [ ! $? = 0 ]; then
    umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
    rm -rf $TMP
    chroot_umount
    echo
    echo "Cancelled!"
    exit
   fi 
   MBR_DEV="`cat $TMP/mbr_dev`"
   ombr_dev="$mbr_dev" #BK
   if [ -n $MBR_DEV ]; then
    mbr_dev="$MBR_DEV"
   fi
   
   #BK bug above, dunno why...
   [ "$mbr_dev" = "" ] && mbr_dev="$ombr_dev"
      
   #BK if probe $mbr_dev; then
   if [ ! "`probepart | grep "$mbr_dev"`" = "" ];then
    break
   else
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfgi: ERROR" --msgbox \
    "I can't find the device '$mbr_dev'." 0 0 #5 45
    continue
   fi
  done
  NUM=0
  grep "^Disk /dev/" $TMP/DEV | cut -d ' ' -f 2 | cut -b 1-8 | while read dev; do
   echo "hd$NUM" >$TMP/mbr_grub_dev
   if [ "$dev" = "$mbr_dev" ]; then
    break
   fi
   NUM=$(( $NUM + 1 ))
  done
  mbr_grub_dev="`cat $TMP/mbr_grub_dev`"
 fi
}

initrd() {
if [ "$ROOT_DEVICE" = "$1" ]; then
if ls $BOOT/initrd* 1>$TMP/null 2>$TMP/null ; then
initrd=`ls -1 -t $BOOT/initrd* | head -n 1`
if [ ! "$3" = "no" ]; then
  kill $INFOPID 2>/dev/null
  $DIALOG --title "Grubconfig: INITRD FOUND" --yesno "Do you want to include \
the initrd '$initrd' in the GRUB config file?" 0 0 #7 66
return=$?
else
return=0
fi
if [ $return = 0 ]; then
    XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox \
    "Creating /boot/grub/$grub_config file on $ROOT_DEVICE.\nPlease wait..." 0 0 25000 & #3 60
    INFOPID=$!
     sleep 3
size=`gzip -l $initrd 2>$TMP/null | grep -v uncompressed_name | awk '{print $2}'`
if [ ! "$size" = "" ]; then
size=$(( $size / 1024 ))
else
size=$(( `ls -l $initrd | awk '{print $5}'` / 1024 ))
fi
  KERNEL="`echo $KERNEL | awk '{print $1,$2,$3}'` ramdisk_size=$size root=/dev/ram0 rw"
  cat << EOF > $2
# Linux bootable initrd config begins
  title Linux initrd $initrd (on $1)
  root ($hd,$p2)
  $KERNEL
  initrd $initrd
# Linux bootable initrd config ends
EOF
fi
fi
fi
}

get_root_dev() {
NUM=0
grep "^Disk /dev/" $TMP/DEV | cut -d ' ' -f 2 | cut -b 1-8 | while read dev; do
echo "hd$NUM" >$TMP/hd_grub
dev2="`echo $1 | cut -b 1-8`"
if [ "$dev" = "$dev2" ]; then
break
fi
NUM=$(( $NUM + 1 ))
done
hd="`cat $TMP/hd_grub`"
}

other() {
 D=`echo "$@" | cut -d ' ' -f 1`
 get_root_dev $D
 
if echo "$@" | grep -q HURD ; then
grub --no-floppy --batch << EOF 1>$TMP/find_file 2>$TMP/null
find ($hd,$p2)/boot/gnumach.gz
quit
EOF
if grep -q "($hd,$p2)" $TMP/find_file ; then
OTHER="root ($hd,$p2)
  kernel /boot/gnumach.gz root=device:$hd"s"$p1
  module /hurd/ext2fs.static --multiboot-command-line=\${kernel-command-line} --host-priv-port=\${host-port} --device-master-port=\${device-port} --exec-server-task=\${exec-task} -T typed \${root} \$(task-create) \$(task-resume)
  module /lib/ld.so.1 /hurd/exec \$(exec-task=task-create)"
echo "GNU/Hurd (on $DOSP)" > $TMP/label
else
OTHER="rootnoverify ($hd,$p2)
  makeactive
  chainloader --force +1"
echo "SCO Unixware (on $DOSP)" > $TMP/label
fi
elif echo "$@" | grep -q BSD ; then
if echo "$@" | grep -q FreeBSD ; then
OTHER="root ($hd,$p2,a)
  kernel /boot/loader"
else  
OTHER="rootnoverify ($hd,$p2)
  chainloader +1"
fi
elif echo "$@" | grep -q QNX ; then
OTHER="map (hd0) ($hd)
  map ($hd) (hd0)
  rootnoverify ($hd,$p2)
  chainloader +4"
elif echo "$@" | grep -q -E "Plan 9|BeOS|Minix" ; then
OTHER="rootnoverify ($hd,$p2)
  chainloader +1"
elif [ ! "$hd" = "hd0" ]; then
if [ "$p2" = "0" ]; then
OTHER="map (hd0) ($hd)
  map ($hd) (hd0)
  rootnoverify ($hd,$p2)
  makeactive
  chainloader +1"
else
OTHER="map (hd0) ($hd)
  map ($hd) (hd0)
  map (hd0,0) ($hd,$p2)
  map ($hd,$p2) (hd0,0)
  rootnoverify ($hd,$p2)
  makeactive
  chainloader +1"
fi
else
if [ "$p2" = "0" ]; then
OTHER="rootnoverify (hd0,$p2)
  makeactive
  chainloader +1"
else
OTHER="map (hd0,0) (hd0,$p2)
  map (hd0,$p2) (hd0,0)
  rootnoverify (hd0,$p2)
  makeactive
  chainloader +1"
fi
fi
}

# This function scans for bootable partitions (making some assumptions along
# the way which may or may not be correct, but usually work), and sets up
# GRUB in either the superblock, or the MBR.
simplegrub()
{
 LOOPBRK="yes" #BK v2.02
 if grep -q "OS/2 Boot Manager" $TMP/DEV 2> $TMP/null ; then
  kill $INFOPID 2>/dev/null
  $DIALOG --title "Grubconfig: OS/2 BOOT MANAGER FOUND" --yesno \
  "Your system appears to have Boot Manager, a boot menu system provided \
with OS/2 and Partition Magic.  If you like, we can install a very simple \
GRUB boot block at the start of your Linux partition.  Then, you can \
add the partition to the Boot Manager menu, and you'll be able to use \
Boot Manager to boot Linux.  Would you like to install GRUB in a Boot \
Manager compatible way?" 0 0 #11 65
  if [ $? = 0 ]; then
    TG=Root
    skip=yes
  fi
fi

#while [ 1 ];do #BIGWHILELOOP BK v2.02

if [ ! "$skip" = "yes" ]; then
 kill $INFOPID 2>/dev/null
 $DIALOG --title "Grubconfig: SELECT GRUB DESTINATION" --menu \
"Pupply Linux users: if choose floppy boot disk here, this script\n\
optionally reruns and redisplays this dialog so you can then choose\n\
to install GRUB to MBR (usually MBR is best hard drive choice).\n\
CLARIFY: Can create boot floppy first, then install to h.d. MBR.\n\
\n\
GRUB can be installed to a variety of places:\n\
\n\
  1. The superblock of a Linux partition '$ROOT_DEVICE',\n\
     (which could be made the bootable partition with DOS or\n\
     Linux fdisk, or booted with a Boot Manager like OS/2 etc.)\n\
  2. A formatted floppy disk.\n\
  3. The Master Boot Record of a hard drive.\n\
\n\
Options 1 and 2 are the safest, but option 1 does require a little\n\
extra work later (setting the partition bootable with fdisk).\n\
Which option would you like? (Cancel button to exit script)" \
 0 0 3 \
 "Root" "Install to superblock of Linux partition" \
 "Floppy" "Install to a floppy in /dev/fd0 (A:)" \
 "MBR" "Install to Master Boot Record (possibly unsafe)" \
 2> $TMP/reply
 if [ ! $? = 0 ]; then
   chroot_umount
   exit
 fi
 TG="`cat $TMP/reply`"
fi
 
 if [ "$TG" = "MBR" ]; then
  hd_mbr
  MBR=YES
 elif [ "$TG" = "Root" ]; then
  MBR=NO
 elif [ "$TG" = "Floppy" ]; then
  GRUB_TARGET="/dev/fd0"
  MBR=NO
  LOOPBRK="no"
 fi

    XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox \
    "Creating /boot/grub/$grub_config file on $ROOT_DEVICE.\nPlease wait..." 0 0 25000 & #3 60
    INFOPID=$!
     sleep 3

 # Search for Linux partitions:
 grep "83  Linux" $TMP/DEV | while read PART ; do 
 if [ ! "$PART" = "" ]; then
  LNXP="`echo $PART | cut -f 1 -d ' '`"
  p1=`echo $LNXP | cut -b9-`
  p2=$(( $p1 - 1 ))

  get_root_dev $LNXP

  KERNEL="kernel /boot/vmlinuz root=$LNXP ro vga=$CONSOLENUM"

  title="Linux (on $LNXP)"

  num="`echo $LNXP | cut -b8-`" 

  cat << EOF > $TMP/part.$num.sort
# Linux bootable partition config begins
  title $title
  root ($hd,$p2)
  $KERNEL
# Linux bootable partition config ends
EOF
initrd $LNXP $TMP/initrd.conf no
 fi
done

 # OK, now let's look for DOS/WIN/OS2/BSD/HURD partitions:
grep "^/dev/" $TMP/DEV | grep -E "DOS|Win95|W95|FAT|BSD|NTFS|HURD|QNX|Minix|Plan|BeOS" | \
grep -v "Ext'd" | grep -v "Extend" | grep -v -i "swap" | while read PART ; do
  if [ ! "$PART" = "" ]; then
  DOSP="`echo $PART | cut -f 1 -d ' '`"
  p1=`echo $DOSP | cut -b9-`
  p2=$(( $p1 - 1 ))
  if echo $PART | grep -q -E "Win95|W95|NTFS" ; then
  LABEL="Windows (on $DOSP)"
  elif echo $PART | grep -q -E "DOS|FAT" ; then
  LABEL="DOS (on $DOSP)"
  elif echo $PART | grep -q "FreeBSD" ; then
  LABEL="FreeBSD (on $DOSP)"
  elif echo $PART | grep -q "OpenBSD" ; then
  LABEL="OpenBSD (on $DOSP)"
  elif echo $PART | grep -q "NetBSD" ; then
  LABEL="NetBSD (on $DOSP)"
  elif echo $PART | grep -q "BSD" ; then
  LABEL="BSD (on $DOSP)"
  elif echo $PART | grep -q "Minix" ; then
  LABEL="Minix (on $DOSP)"
  elif echo $PART | grep -q "QNX" ; then
  LABEL="QNX (on $DOSP)"
  elif echo $PART | grep -q "BeOS" ; then
  LABEL="BeOS (on $DOSP)"
  elif echo $PART | grep -q "Plan 9" ; then
  LABEL="Plan 9 (on $DOSP)"
  fi

  other $PART

  if echo $PART | grep -q "HURD" ; then
  LABEL="`cat $TMP/label`"
  fi

  num="`echo $DOSP | cut -b8-`" 

  cat << EOF > $TMP/part.$num.sort
# Other bootable partition config begins
  title $LABEL
  $OTHER
# Other bootable partition config ends
EOF
fi
done
 # Done, now we must install GRUB:
 chmod 644 $BOOT/grub/$grub_config
 message=yes
 installcolor;
 
#  # BK v2.02...
#  if [ "$LOOPBRK" = "yes" ];then
   umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
   rm -rf $TMP
#   break 
#  fi
# done #BIGWHILELOOP BK
 #something wrong with trying to have a while loop here.
 #instead, a flag to rerun grubconfig...
 echo -n "$LOOPBRK" > /tmp/loopbrk.txt
 
} #end simplegrub func.

find_kernel() {
cat << EOF > $TMP/tmpmsg
`echo "   Device Boot      Start         End      Blocks   Id  System"`
`grep "^$PART" $TMP/fdisk.list`

Where on the above Linux partition is the kernel you
want GRUB to boot?

The default is '/boot/vmlinuz'. Just press enter for it.
EOF

    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: KERNEL LOCATION" --cr-wrap --inputbox "`cat $TMP/tmpmsg`" 0 0 2> $TMP/kernel
    if [ $? = 1 -o $? = 255 ]; then
      umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
      rm -rf $TMP
      chroot_umount
      echo
      echo "Cancelled!"
      exit
    else
      kernel="`cat $TMP/kernel`"
    if [ "$kernel" = "" ]; then
      KERNEL="kernel /boot/vmlinuz root=$PART ro vga=$CONSOLENUM"
    else
      KERNEL="kernel $kernel root=$PART ro vga=$CONSOLENUM"
    fi
   fi

cat << EOF > $TMP/tmpmsg
`echo "   Device Boot      Start         End      Blocks   Id  System"`
`grep "^$PART" $TMP/fdisk.list`

`echo $KERNEL | cut -d ' ' -f 2-`

Do you want to pass any other options to the above kernel?
For example: hdd=scsi foo=boo

Put then on one line one after the other or leave box blank.
EOF

    kill $INFOPID 2>/dev/null
    $DIALOG --title "KERNEL OPTIONS" --cr-wrap --inputbox "`cat $TMP/tmpmsg`" 0 0 2> $TMP/reply
    APPEND="`cat $TMP/reply`"
}

install_grub()
{
NUM=0
grep "^Disk /dev/" $TMP/DEV | cut -d ' ' -f 2 | cut -b 1-8 | while read dev; do
echo "hd$NUM" >$TMP/root_dev
dev2="`echo $ROOT_DEVICE | cut -b 1-8`"
if [ "$dev" = "$dev2" ]; then
break
fi
NUM=$(( $NUM + 1 ))
done
root_dev="`cat $TMP/root_dev`"

     p1=`echo $ROOT_DEVICE | cut -b 9-`
     p2=$(( $p1 - 1 ))

rm -f $TMP/grub.conf
for f in `ls $TMP/part.*.sort`
do
cat $f >> $TMP/grub.conf
done

if [ -f $TMP/initrd.conf ]; then
  cat $TMP/initrd.conf >> $TMP/grub.conf
fi

cat << EOF >> $TMP/grub.conf
title Install GRUB to floppy disk (on /dev/fd0)
pause Insert a formatted floppy disk and press enter.
root ($root_dev,$p2)
setup (fd0)
pause Press enter to continue.
title Install GRUB to Linux partition (on $ROOT_DEVICE)
root ($root_dev,$p2)
setup ($root_dev,$p2)
pause Press enter to continue.
EOF

cat << EOF >> $TMP/grub.conf
title -     For help press 'c', then type: 'help'
root (hd0)
title -     For usage examples, type: 'cat /boot/grub/usage.txt'
root (hd0)
EOF

cat << EOF > $BOOT/grub/usage.txt
=======================================================================
This is an example of how to use the GRUB edit function.

Highlight the menu entry you want to edit, then press 'e', then
highlight the line you want to edit and press 'e'. Add what
you want to the line 'hdd=scsi' etc. and press enter, then
'b' to boot.

Examples of the difference between Linux and GRUB device names.

Linux IDE:	GRUB IDE:	Linux SCSI:	GRUB SCSI:
/dev/hda1       (hd0,0)		/dev/sda1       (hd0,0)
/dev/hda2       (hd0,1)		/dev/sda2       (hd0,1)
/dev/hda3       (hd0,2)		/dev/sda1       (hd0,2)
/dev/hda4       (hd0,3)		/dev/sda2       (hd0,3)
/dev/hdb1       (hd1,0)		/dev/sdb1       (hd1,0)
/dev/hdb2       (hd1,1)		/dev/sdb2       (hd1,1)
/dev/hdb3       (hd1,2)		/dev/sdb1       (hd1,2)
/dev/hdb4       (hd1,3)		/dev/sdb2       (hd1,3)

These are some examples of how to use GRUB from the command prompt.

Press the 'c' key for the command prompt.

If you want to boot a Linux system on a partition, using it's kernel
/boot/vmlinuz etc., do this.

grub> root (hd0,1)
grub> kernel /boot/vmlinuz root=/dev/hda2 ro
grub> boot

You could do this to find what partition the kernel is on.
For example, show me what partitions have a /boot/vmlinuz.

grub> find /boot/vmlinuz
(hd0,1)
(hd0,2)

If you want to boot a Dos/Win partition, do this.

For example, boot partition on /dev/hda1.

grub> rootnoverify (hd0,0)
grub> makeactive
grub> chainloader +1
grub> boot

If you want to boot a FreeBSD partition using /boot/loader.

For example, boot freebsd partition on /dev/hda4.

grub> root (hd0,3,a)
grub> kernel /boot/loader
grub> boot

If that doesn't work, try this instead.

grub> rootnoverify (hd0,3,a)
grub> chainloader +1
grub> boot
==============================================================

Press the [Esc] key to return to the GRUB menu.
EOF

if [ "$MBR" = "NO" ]; then
if [ "$GRUB_TARGET" = "/dev/fd0" ]; then
rm -f $BOOT/grub/device.map
grub --device-map=$BOOT/grub/device.map --batch << EOF 1>$TMP/null 2>$TMP/null
root ($root_dev,$p2)
setup (fd0)
quit
EOF
SUCCESS=$?
installed="installed on the floppy disk"
else
rm -f $BOOT/grub/device.map
grub --device-map=$BOOT/grub/device.map --no-floppy --batch << EOF 1>$TMP/null 2>$TMP/null
root ($root_dev,$p2)
setup ($root_dev,$p2)
quit
EOF
SUCCESS=$?
installed="installed on the Linux partition $ROOT_DEVICE"
fi
else
dd if=$mbr_dev of=$BOOT/grub/mbr.`echo $mbr_dev | cut -b 6-8`.$$ bs=512 count=1 >$TMP/null 2>&1 && \
backup_mbr=$BOOT/grub/mbr.`echo $mbr_dev | cut -b 6-8`.$$
rm -f $BOOT/grub/device.map
grub --device-map=$BOOT/grub/device.map --no-floppy --batch << EOF 1>$TMP/null 2>$TMP/null
root ($root_dev,$p2)
setup ($mbr_grub_dev)
quit
EOF
SUCCESS=$?
installed="installed on the MBR of $mbr_dev"
fi  

      if [ -r $BOOT/grub/$grub_config ]; then
       mv $BOOT/grub/$grub_config $BOOT/grub/$grub_config.old.$$
      fi

if [ ! "$backup_mbr" = "" ]; then
mbr_backup=`basename $backup_mbr` 
 cat << EOF > $BOOT/grub/$grub_config
# GRUB configuration file '/boot/grub/$grub_config'.
# generated by 'grubconfig'.  `date +%c 2>$TMP/null`
#
# The backup copy of the MBR for drive '$mbr_dev' is
# here '/boot/grub/$mbr_backup'.  You can restore it like this.
# dd if=/boot/grub/$mbr_backup of=$mbr_dev bs=512 count=1
#
# Start GRUB global section
#timeout 30
color light-gray/blue black/light-gray
# End GRUB global section
EOF
else
 cat << EOF > $BOOT/grub/$grub_config
# GRUB configuration file '/boot/grub/$grub_config'.
# generated by 'grubconfig'.  `date +%c 2>$TMP/null`
#
# Start GRUB global section
#timeout 30
color light-gray/blue black/light-gray
# End GRUB global section
EOF
fi
cat $TMP/grub.conf >> $BOOT/grub/$grub_config
chmod 644 $BOOT/grub/$grub_config
}

installcolor()
{
if [ "$GRUB_TARGET" = "/dev/fd0" ]; then
while :
do
     kill $INFOPID 2>/dev/null
     $DIALOG --title "Grubconfig: FLOPPY DISK" --menu \
"The floppy should be formatted. \n\
Put the floppy in the drive and press enter." 10 55 2 \
 "Ready" "The floppy is already formatted" \
 "Format" "Format the floppy first" 2> $TMP/reply
      if [ ! $? = 0 ]; then
        chroot_umount
        exit
      elif ! (dd if=/dev/fd0 of=$TMP/null bs=1 count=1 1>$TMP/null 2>$TMP/null) ; then
        continue
      fi
      REPLY="`cat $TMP/reply`"
      if [ "$REPLY" = "Format" ]; then
      [ -b /dev/fd0h1440 ] && fd=/dev/fd0h1440
      [ -b /dev/fd0H1440 ] && fd=/dev/fd0H1440
      [ -b /dev/fd0u1440 ] && fd=/dev/fd0u1440
      #BK...
      #if [ -x "`type -path fdformat`" ]; then
        XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox \
        "Formatting floppy:\nfdformat -n $fd \nPlease wait..." 0 0 25000 & #3 35
        INFOPID=$!
        fdformat -n $fd || continue
      #elif [ -x "`type -path superformat`" ]; then
      #  $DIALOG --title "Formatting floppy..." --infobox \
      #  "superformat -f $fd" 3 35
      #  superformat -f $fd || continue
      #else
      #   $DIALOG --title "ERROR" --msgbox \
      #  "Can't find 'fdformat' or 'superformat' to format floppy." 5 65
      #   continue
      #fi
      fi
        break
done
fi

   kill $INFOPID 2>/dev/null
   XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox "Installing the GRUB Bootloader..." 0 0 25000 & #5 40
   INFOPID=$!
   sleep 2 
 
   if [ ! "$KILL" = "NO" ]; then
   killall klogd 2>$TMP/null
   sleep 1
   klogd -c 3 2>$TMP/null
   fi
   
   install_grub
 
 if [ ! "$SUCCESS" = "0" ]; then # some GRUB error occured
  if [ ! "$backup_mbr" = "" -a ! "$mbr_dev" = "" ]; then
  if [ -s "$backup_mbr" ]; then
  if dd if=$mbr_dev bs=512 count=1 | grep -q GRUB ; then
    dd if=$backup_mbr of=$mbr_dev bs=512 count=1 >$TMP/null 2>&1
  fi
  fi
  fi
  kill $INFOPID 2>/dev/null
  $DIALOG --title "GRUB INSTALL ERROR # $SUCCESS" --msgbox \
  "Sorry, but the attempt to install GRUB has returned an error, so GRUB \
  has not been correctly installed.  You'll have to use a bootdisk \
  to start your \
  machine instead.  It may be possible to get GRUB working by \
  editing the /boot/grub/$grub_config file and reinstalling GRUB manually. \
  See the GRUB man page and info documentation in /usr/info for more help." 11 60
 else
  if [ "$message" = "yes" ]; then
cat << EOF >$TMP/tmpmsg

GRUB was successfully $installed.

You should check and edit the '/boot/grub/$grub_config'
file on '$ROOT_DEVICE', if needed. You may want to change
the location '/boot/vmlinuz', and/or options passed to any
Linux kernel listed there.

EOF
   kill $INFOPID 2>/dev/null
   $DIALOG --title "GRUB INSTALL SUCCESS" --msgbox "`cat $TMP/tmpmsg`" 0 0 #12 70
  else
   kill $INFOPID 2>/dev/null
   $DIALOG --title "GRUB INSTALL SUCCESS" --msgbox \
   "GRUB was successfully $installed." 0 0 #5 70
  fi
 fi
}

#BK not using this, had trouble with it...
## 'probe()' borrowed from GRUB QuickInst.
#probe()
#{
# [ ! -z "`dd if=$1 bs=1 count=1 2>$TMP/null | tr '\0' x`" ]
# return
#}

   #BK...
   DIALOG="`which Xdialog`"
   #DIALOG=`type -path dialog`
   #if [ ! -x "$DIALOG" ]; then
   #  echo "This script requires the 'dialog' program to run."
   #  chroot_umount
   #  exit 1
   #fi

 if [ ! `whoami` = "root" ]; then
     $DIALOG --title "NOT ROOT" --msgbox \
     "You need to be 'root' to run this script." 0 0 #5 50
     chroot_umount
     exit
 fi

 #BK...
 if [ ! -x "`which grub`" ]; then
 #if [ ! -x "`type -path grub`" ]; then
     $DIALOG --title "CAN'T FIND GRUB" --msgbox \
     "I can't find 'grub' on the system." 0 0 #5 40
     chroot_umount
     exit
 fi

 BOOT=/boot
 #BK...
 if grep -q $BOOT/grub/grub.conf 2>$TMP/null `which grub` ; then
 #if grep -q $BOOT/grub/grub.conf 2>$TMP/null `type -path grub` ; then
   grub_config=grub.conf
 else
   grub_config=menu.lst
 fi

root_device() {
# Determine the root partition (such as /dev/hda2)
    ROOT_DEVICE="`mount 2>$TMP/null | grep " on / " | awk '{print $1}'`"

  if [ -z "$ROOT_DEVICE" -a -s /etc/fstab ]; then
    ROOT_DEVICE="`grep -v "^#" /etc/fstab 2>$TMP/null | grep " / " | awk '{print $1}'`"
  fi
  
  if [ -n "$ROOT_DEVICE" ]; then
  if echo $ROOT_DEVICE | grep -q -E "/dev/ram|/dev/root|tmpfs|rootfs|/dev/loop"; then
    unset ROOT_DEVICE
  fi
  fi

  #BK quick hack for puppy2...
  [ "$ROOT_DEVICE" = "none" ] && ROOT_DEVICE=""
  #BK quick hack for v2.16...
  [ "$ROOT_DEVICE" = "unionfs" ] && ROOT_DEVICE=""
  
    if [ -n "$ROOT_DEVICE" ]; then
cat << EOF > $TMP/tmpmsg
Where do you want the GRUB files to go?

The default is to put them in /boot/grub on the current
partition '$ROOT_DEVICE'.  To accept this default, leave
the line below unchanged and hit ENTER (this should be
fine for most users).  If (for some reason) you want to
use a different partition, change it on the line below
and hit ENTER.
EOF
else
cat << EOF > $TMP/tmpmsg
Puppy Linux users: If running from the Universal Installer,\n
                   just accept default entry, click OK button.\n
\n
Where do you want the GRUB files to go?\n
\n
Usually they are put with the kernel in the /boot directory.\n
What partition has the /boot directory you want to use?\n
Put the partition (/dev/hda2 etc.) in the box below:
EOF
    fi

while :
do
 if [ "$ROOT_DEVICE" ];then #BK initialise text box...
  BKINITIAL_DEVICE="$ROOT_DEVICE"
 else
  BKINITIAL_DEVICE="$BKPASSED_DEVICE"
 fi

#BK    $DIALOG --title "SELECT GRUB PARTITION" --inputbox "`cat $TMP/tmpmsg`" 0 0 "$ROOT_DEVICE" 2> $TMP/root_device
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: SELECT GRUB PARTITION" --no-collapse --inputbox "`cat $TMP/tmpmsg`" 0 0 "$BKINITIAL_DEVICE" 2> $TMP/root_device
    if [ ! $? = 0 ]; then
      umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
      rm -rf $TMP
      chroot_umount
      exit
    fi    
      ROOT_DEV=`cat $TMP/root_device`

     if [ "$ROOT_DEVICE" = "" -a "$ROOT_DEV" = "" ]; then
       continue
     fi

     if [ "$ROOT_DEVICE" = "$ROOT_DEV" ]; then
       break
     fi
    
       if [ ! "$ROOT_DEV" = "" ]; then
         ROOT_DEVICE=`cat $TMP/root_device`
       fi
    
        if ! grep "^$ROOT_DEVICE" $TMP/DEV | grep -q "83  Linux" ; then
         kill $INFOPID 2>/dev/null
	     $DIALOG --title "Grubconfig: ERROR" --msgbox \
          "The partition '$ROOT_DEVICE' is not Linux." 0 0 #5 55
	  continue
        fi
       
       if mount 2>$TMP/null | grep -q "^$ROOT_DEVICE" 2>$TMP/null ; then
           BOOT="`mount 2>$TMP/null | grep $ROOT_DEVICE | cut -d ' ' -f 3`/boot"
         if echo "fooboo" > $BOOT/fooboo 2>$TMP/null ; then
 	      rm -f $BOOT/fooboo
         else
          kill $INFOPID 2>/dev/null
 	      $DIALOG --title "Grubconfig: ERROR" --msgbox \
           "The partition '$ROOT_DEVICE' is mounted read-only, \
           either unmount it or mount it read-write." 0 0 #6 55
           rm -rf $TMP
           chroot_umount
	   exit
	 fi
           break
       else
       umount $BOOT_TMP 2>$TMP/null
       mkdir -p $BOOT_TMP
       mount -o rw $ROOT_DEVICE $BOOT_TMP 1>$TMP/null 2>$TMP/error
       if [ ! $? = 0 ]; then
       echo "" >> $TMP/error
       echo "I couldn't mount '$ROOT_DEVICE' read-write!" >> $TMP/error
       kill $INFOPID 2>/dev/null
       $DIALOG --title "Grubconfig: MOUNT ERROR" --textbox "$TMP/error" 0 0
       umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
       rm -rf $TMP
       chroot_umount
       exit
       fi
       BOOT=$BOOT_TMP/boot
       break
       fi
 done

    XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox "Working, please wait..." 0 0 25000 & #3 20
    INFOPID=$!
    sleep 1
    
 fs=`mount | grep "^$ROOT_DEVICE" | awk '{print $5}'`
 [ "$fs" = "ext2" -o "$fs" = "ext3" -o "$fs" = "ext4" ] && fs=e2fs #v423 kirk: add ext4. v424 typo.
 [ "$fs" = "msdos" ] && fs=fat
 [ "$fs" = "vfat" ] && fs=fat
 
 if [ -d /usr/share/grub -o -d /usr/lib/grub -o -d /usr/local/share/grub ]; then
 mkdir -p $BOOT/grub
 if [ -d /usr/share/grub ]; then
 cp-FULL -p /usr/share/grub/*/*stage* $BOOT/grub 2>$TMP/null
 elif [ -d /usr/local/share/grub ]; then
 cp-FULL -p /usr/local/share/grub/*/*stage* $BOOT/grub 2>$TMP/null
 elif [ -d /usr/lib/grub ]; then
 cp-FULL -p /usr/lib/grub/*/*stage* $BOOT/grub 2>$TMP/null
 fi
 
 for f in stage1 stage2 $fs"_stage1_5"
 do
 if [ ! -f $BOOT/grub/$f ]; then
 echo "ERROR: Can't find '$f' from the grub package."
 echo "If you have the grub package installed, you should have a"
 echo "/usr/lib/grub, /usr/share/grub, or /usr/local/share/grub"
 echo "directory, containing the stage files."
 chroot_umount
 exit 1
 fi 
 done
 else
 echo "ERROR: Can't find stage files from the grub package."
 echo "If you have the grub package installed, you should have a"
 echo "/usr/lib/grub, /usr/share/grub, or /usr/local/share/grub"
 echo "directory, containing the stage files."
 chroot_umount
 exit 1
 fi
}

HDR="no" # this means the header section of /boot/grub/menu.lst has not yet
         # been configured
LNX="no" # this means no Linux partition has been defined as bootable
         # through GRUB. Both of these must change to "yes" before GRUB will
         # install from this script.
 
 # OK, now let's see if we should automate things:
 $DIALOG --title "GRUBCONFIG Kent Robotti (modified for Puppy Linux)" --no-collapse --menu \
 "Puppy Linux users: if running this from the Universal Installer,\n\
                    please choose 'simple' option!\n\
 \n\
 GRUB is a generic bootloader.  There's a simple installation which tries\n\
 to automatically set up GRUB to boot Linux (also DOS, Windows, BSD, HURD,\n\
 QNX, PLAN9, BEOS, Minix, and OS/2 if found).  For more advanced users,\n\
 the expert option offers more control over the installation process." 0 0 3 \
 "simple" "Try to install GRUB automatically" \
 "expert" "Use expert GRUB setup menu" 2> $TMP/reply
 if [ ! $? = 0 ]; then
  rm -rf $TMP
  chroot_umount
  echo
  exit
 fi

  REPLY="`cat $TMP/reply`"

  if [ ! -f /proc/partitions ]; then
    CHROOT=YES
    mkdir -p /proc
    mount -t proc proc /proc
  fi

 if [ "$REPLY" = "simple" ]; then
  # Do simple GRUB setup
   use_framebuffer
   XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox "Working, please wait..." 0 0 25000 & #BK 3 20
   INFOPID=$!
   sleep 1
   create_devices
   root_device
   killall klogd 2>$TMP/null
   sleep 1
   klogd -c 3 2>$TMP/null
   KILL=NO
   simplegrub
   umount $BOOT_TMP 2>$TMP/null
   rm -rf $TMP
   test_boot_tmp_func #v424
   rm -rf $BOOT_TMP
   chroot_umount
   exit
 fi
 # drop through to last option: (use the expert menus)
 while [ 0 ]; do
  $DIALOG --title "EXPERT GRUB INSTALLATION" --menu \
"This menu directs the creation of the GRUB config file. \
To install, you make a new GRUB configuration file by creating a new header \
and then adding one or more bootable partitions to the file. Once you've done \
this, you can select the install option. If you make \
a mistake, you can always start over by choosing 'Begin'. \
Which option would you like?" 18 76 7 \
"Begin" "Start GRUB configuration with a new GRUB header" \
"Linux" "Add Linux partition to GRUB config file" \
"Other" "Add DOS/WIN/BSD/OS2/HURD partition to GRUB config file" \
"Install" "Install GRUB" \
"Skip" "Skip GRUB installation or exit this menu" \
"View" "View your current /boot/grub/$grub_config" \
"Help" "Read the GRUB Bootloader HELP file" 2> $TMP/reply
  if [ ! $? = 0 ]; then
   REPLY="Skip"
  else
   REPLY="`cat $TMP/reply`"
  fi
  if [ "$REPLY" = "Begin" ]; then
    use_framebuffer

    XDIALOG_HIGH_DIALOG_COMPAT=false $DIALOG --title "Grubconfig" --no-buttons --infobox "Working, please wait..." 0 0 25000 & #3 20
    INFOPID=$!
    sleep 1

    create_devices

   kill $INFOPID 2>/dev/null
   $DIALOG --title "SELECT GRUB TARGET LOCATION" --menu "GRUB can be installed \
to a variety of places: the master boot record of a hard drive, \
the superblock of a Linux partition (which could be made \
active with fdisk, or booted with a boot manager), or a formatted floppy disk, \
If you're using a boot system such as OS/2's Boot Manager, you should use \
the "Root" selection. Please pick a target location:" 15 68 3 \
"Root" "Use superblock of Linux partition" \
"Floppy" "Use a formatted floppy disk in the boot drive" \
"MBR" "Use the Master Boot Record (possibly unsafe)" \
2> $TMP/reply
   if [ $? = 1 -o $? = 255 ]; then
    HDR="no"
    continue;
   else
    LNX="no"
    TG="`cat $TMP/reply`"
   fi
   if [ "$TG" = "MBR" ]; then
    hd_mbr
    MBR=YES
   elif [ "$TG" = "Root" ]; then
    MBR=NO
   elif [ "$TG" = "Floppy" ]; then
    GRUB_TARGET="/dev/fd0"    
    MBR=NO
   else
    HDR="no"
    continue;
   fi
    HDR="yes"
    root_device
  elif [ "$REPLY" = "Linux" ]; then
   if [ "$HDR" = "yes" ]; then
echo "Press the [Space] key to untag any you don't want to include." > $TMP/tmpmsg1
echo "Device Boot Start End Blocks Id System" >> $TMP/tmpmsg1
grep "^/dev/" $TMP/DEV | grep "83  Linux" | grep -v "Ext'd" | grep -v "Extend" > $TMP/tmpmsg2

if [ -s $TMP/tmpmsg2 ]; then
echo '$DIALOG --title "POSSIBLE LINUX PARTITIONS" --cr-wrap --checklist "`cat $TMP/tmpmsg1`" 0 0 0 \' > $TMP/tmpmsg3
cat $TMP/tmpmsg2 | sed "/^$/d" | while read device ; do
device_name="`echo "$device" | awk '{print $1}'`"
device_info="`echo "$device" | awk '{print $2,$3,$4,$5,$6,$7}'`"
echo "$device_name" | sed "/^$/d" | sed -e 's/.*/"&" '"'$device_info'"' on \\/' >> $TMP/tmpmsg3
done
echo "2> $TMP/parts" >> $TMP/tmpmsg3

    . $TMP/tmpmsg3
    if [ $? = 1 -o $? = 255 ]; then
     rm -f $TMP/tmpmsg*
     continue
    else
     cat $TMP/tmpmsg2 > $TMP/fdisk.list
     rm -f $TMP/tmpmsg*
    fi
else
      $DIALOG --title "Grubconfig" --msgbox \
     "No Linux partitions found!" 0 0 #5 35
      continue
fi
    
    if [ -s $TMP/parts ]; then
      cat $TMP/parts | sed "s/\"//g" | sed "/^$/d" > $TMP/parts.a
    else
      $DIALOG --title "Grubconfig" --msgbox \
     "No Linux partitions chosen!" 0 0 #5 35
      continue
    fi
        
    for PART in `cat $TMP/parts.a` ; do

cat << EOF > $TMP/tmpmsg
`echo "   Device Boot      Start         End      Blocks   Id  System"`
`grep "^$PART" $TMP/fdisk.list`

Now you must select a name for the above partition.
You'll use this name to specify a partition to boot from
the GRUB menu.  Something like 'Slackware Linux' might
not be a bad choice.

The default is 'Linux (on $PART)'.  Just press ENTER for it.
(the menu will add '(on $PART)' for you automatically)
EOF
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: SELECT PARTITION NAME" --cr-wrap --inputbox "`cat $TMP/tmpmsg`" 0 0 2> $TMP/reply
    if [ ! $? = 0 ]; then
     break;
    fi
     LABEL="`cat $TMP/reply`"
    if [ "$LABEL" = "" ]; then
     LABEL="Linux"
    fi    
    
  p1=`echo $PART | cut -b 9-`
  p2=$(( $p1 - 1 ))

  find_kernel
  get_root_dev $PART

  num="`echo $PART | cut -b8-`" 

  cat << EOF > $TMP/part.$num.sort
# Linux bootable partition config begins
  title $LABEL (on $PART)
  root ($hd,$p2)
  $KERNEL $APPEND
# Linux bootable partition config ends
EOF
initrd $PART $TMP/initrd.conf
done
   else
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: CAN'T ADD LINUX PARTITION" --msgbox "You can't add \
partitions unless you start over with a new GRUB header." 0 0 #6 60
    continue
   fi
   LNX="yes"
  elif [ "$REPLY" = "Other" ]; then
   if [ "$HDR" = "yes" ]; then
   rm -f $TMP/parts
echo "Press the [Space] key to untag any you don't want to include." > $TMP/tmpmsg1
echo "Device Boot Start End Blocks Id System" >> $TMP/tmpmsg1
grep "^/dev/" $TMP/DEV | grep -E "DOS|Win95|W95|FAT|NTFS|BSD|HURD|QNX|BeOS|Minix|Plan" | \
grep -v "Ext'd" | grep -v "Extend" | grep -v -i "swap" > $TMP/tmpmsg2

if [ -s $TMP/tmpmsg2 ]; then
echo '$DIALOG --title "POSSIBLE DOS/WIN/OS2/BSD etc. PARTITIONS" --cr-wrap --checklist "`cat $TMP/tmpmsg1`" 0 0 0 \' > $TMP/tmpmsg3
cat $TMP/tmpmsg2 | sed "/^$/d" | while read device ; do
device_name="`echo "$device" | awk '{print $1}'`"
device_info="`echo "$device" | awk '{print $2,$3,$4,$5,$6,$7}'`"
echo "$device_name" | sed "/^$/d" | sed -e 's/.*/"&" '"'$device_info'"' on \\/' >> $TMP/tmpmsg3
done
echo "2> $TMP/parts" >> $TMP/tmpmsg3

    . $TMP/tmpmsg3
    if [ ! $? = 0 ]; then
     rm -f $TMP/tmpmsg*
     continue
    else
     cat $TMP/tmpmsg2 > $TMP/fdisk.list
    fi
fi

    if [ ! -s $TMP/tmpmsg2 ]; then
      $DIALOG --title "Grubconfig" --msgbox \
     "No Other partitions found!" 0 0 #5 35
      rm -f $TMP/tmpmsg*
      continue
    elif [ -s $TMP/parts ]; then
      cat $TMP/parts | sed "s/\"//g" | sed "/^$/d" > $TMP/parts.a
    else
      $DIALOG --title "Grubconfig" --msgbox \
     "No Other partitions chosen!" 0 0 #5 35
      rm -f $TMP/tmpmsg*
      continue
    fi
      rm -f $TMP/tmpmsg*
    
    for PART in `cat $TMP/parts.a` ; do
cat << EOF > $TMP/tmpmsg
`echo "   Device Boot      Start         End      Blocks   Id  System"`
`grep "^$PART" $TMP/fdisk.list`

Now you must select a name for the above partition.
You'll use this name to specify a partition to boot from
the GRUB menu. 'DOS, Win2k, WinXP, FreeBSD, GNU/Hurd,
etc.' might not be a bad choice.
EOF

    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: SELECT PARTITION NAME" --cr-wrap --inputbox "`cat $TMP/tmpmsg`" 0 0 2> $TMP/reply
    if [ ! $? = 0 ]; then
     break;
    fi
     LABEL="`cat $TMP/reply`"
    if [ "$LABEL" = "" ]; then
     LABEL=Unknown
    fi    
    p1=`echo $PART | cut -b 9-`
    p2=$(( $p1 - 1 ))

    part=`grep "^$PART" $TMP/fdisk.list`

    other $part

    num="`echo $PART | cut -b8-`" 

  cat << EOF > $TMP/part.$num.sort
# Other bootable partition config begins
  title $LABEL (on $PART)
  $OTHER
# Other bootable partition config ends
EOF
done
   else
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: CAN'T ADD OTHER PARTITION" --msgbox "You can't add \
partitions unless you start over with a new GRUB header." 0 0 #6 60
    continue
   fi
  elif [ "$REPLY" = "Install" ]; then
   if [ "$LNX" = "no" ]; then
    kill $INFOPID 2>/dev/null
    $DIALOG --title "Grubconfig: CAN'T INSTALL GRUB" --msgbox "GRUB could not be \
installed. If you have not created a GRUB configuration file by defining \
a new header and adding at least one Linux bootable partition to it, you \
must do so before installing GRUB." 8 70
    continue
   else
       installcolor;
       umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
       rm -rf $TMP
   fi
   rm -f $TMP/tmpmsg
   break
  elif [ "$REPLY" = "Skip" ]; then
   umount $BOOT_TMP 2>$TMP/null && rmdir $BOOT_TMP
   rm -rf $TMP
   chroot_umount
   break
  elif [ "$REPLY" = "View" ]; then
  
  rm -f $TMP/view.conf
  if ls $TMP/part.*.sort 2>$TMP/null ; then
  for f in `ls $TMP/part.*.sort`
  do
    cat $f >> $TMP/view.conf
  done
  fi
  
  if [ -f $TMP/initrd.conf ]; then
    cat $TMP/initrd.conf >> $TMP/view.conf
    rm -f $TMP/initrd.conf
  fi
   
   if [ -r $TMP/view.conf ]; then
    kill $INFOPID 2>/dev/null
    $DIALOG --title "YOUR NEW /boot/grub/$grub_config" --textbox "$TMP/view.conf" 22 70
   else
    if [ -r $BOOT/grub/$grub_config ]; then
     kill $INFOPID 2>/dev/null
     $DIALOG --title "YOUR CURRENT /boot/grub/$grub_config" --textbox "$BOOT/grub/$grub_config" 22 70
    else
     kill $INFOPID 2>/dev/null
     $DIALOG --title "NO CONFIG FILE FOUND" --msgbox "Sorry, but you don't \
have a GRUB configuration file that can be viewed." 0 0 #6 60
    fi
   fi
  elif [ "$REPLY" = "Help" ]; then
cat << EOF > $TMP/tmpmsg

This script 'grubconfig' helps you install the GRUB bootloader
on your Linux system.

It supports IDE and SCSI devices, it has no support for RAID devices.

These are the options you can use at the GRUB expert install menu:

1. Start GRUB configuration with a new GRUB header.

   This is the first step to start a new configuration file,
   /boot/grub/$grub_config, with no OS's entered into it (yet).

   You'll be asked where you want to install GRUB. This
   can be to your Master Boot Record, a Linux partition's
   superblock (for OS/2's Boot Manager etc. to boot), or
   to a 1.44MB formatted floppy disk. 
   
   Try installing to a floppy disk first, if it works
   on the floppy it will probably work on the MBR or
   superblock.
   
   Once you've started a new /boot/grub/$grub_config file, you must
   add at least one OS to it before you can install GRUB.

   Next you'll want to add at least one Linux partition, the
   one that will hold the GRUB files in /boot/grub.

   You then may want to add other partitions if you have any.
   
2. Menu choices to add Linux and other DOS/WIN/BSD/OS2/HURD/QNX/
   PLAN9/BEOS/Minix partitions to the /boot/grub/$grub_config
   file.

   These all pretty much work the same way. You'll be asked 
   which partitions you want to include in the grub menu, and 
   you'll also be asked to assign a label to each partition.
   The label can be any name such as "Slackware Linux" or
   "WinXP" etc.

3. Install GRUB
   
   Once you've looked at your new config file and are 
   satisfied with the way it looks, pick this option to 
   install GRUB and exit the GRUB installation menu.

Other options:

  -- View your current /boot/grub/$grub_config file

   If you haven't begun building a new $grub_config file, this choice
   will let you take a look at the existing one in /boot/grub
   on your GRUB Linux partition. 

   If you have begun constructing a new $grub_config file, this
   option will let you view the progress on that.

 -- Skip GRUB installation or exit this menu

  This option skips GRUB installation. Use this if you don't 
  want to install GRUB, or if you've already installed it and 
  want to exit.

 -- Help - Read this GRUB Bootloader HELP file 
 
-----------

Other GRUB information:

  GRUB on the Master Boot Record can be removed easily. 
  DOS/Win9x fdisk has a 'C:\ fdisk /mbr' option that restores the
  original master boot record. You can also restore your original boot
  sector from the copy 'grubconfig' makes in /boot/grub/mbr.device.number.
  
  This is probably the best way to go about it.
  # dd if=/boot/grub/mbr.device.number of=/dev/device bs=512 count=1
  
  If you want to make any changes you don't need to run grubconfig
  again, you can just edit /boot/grub/$grub_config by hand.
  
--- end of GRUB help

grubconfig is based on liloconfig by Patrick Volkerding fron the
Slackware Linux distribution.
EOF
   $DIALOG --title "GRUB INSTALLATION HELP" --textbox "$TMP/tmpmsg" 22 74
  fi
 done

###the end###
