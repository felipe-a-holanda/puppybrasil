Content-type: text/html

<HTML><HEAD><TITLE>Manpage of aufs</TITLE>
</HEAD><BODY>
<H1>aufs</H1>
Section: Linux Aufs User\[aq]s Manual (5)<BR>Updated: AUFS_VERSION]<BR><A HREF="#index">Index</A>
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

aufs - advanced multi layered unification filesystem. version AUFS_VERSION]
<P>

<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

Aufs is a stackable unification filesystem such as Unionfs, which unifies
several directories and provides a merged single directory.
In the early days, aufs was entirely re-designed and re-implemented
Unionfs Version 1.x series. After
many original ideas, approaches and improvements, it
becomes totally different from Unionfs while keeping the basic features.
See Unionfs Version 1.x series for the basic features.
Recently, Unionfs Version 2.x series begin taking some of same
approaches to aufs[aq]s.
<P>

<A NAME="lbAD">&nbsp;</A>
<H2>MOUNT OPTIONS</H2>

At mount-time, the order of interpreting options is,
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>*<DD>

simple flags, except xino/noxino and udba=inotify

<DT>*<DD>

branches

<DT>*<DD>

xino/noxino

<DT>*<DD>

udba=inotify
</DL>
</DL>

<P>
At remount-time,
the options are interpreted in the given order,
e.g. left to right.
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>*<DD>

create or remove
whiteout-base(AUFS_WH_BASE]) and
whplink-dir(AUFS_WH_PLINKDIR]) if necessary
</DL>
</DL>

<DL COMPACT>
<DT><B>br:BRANCH[:BRANCH ...] (dirs=BRANCH[:BRANCH ...])</B>

<DD>
Adds new branches.
(cf. Branch Syntax).
<P>
Aufs rejects the branch which is an ancestor or a descendant of another
branch. It is called overlapped. When the branch is loopback-mounted
directory, aufs also checks the source fs-image file of loopback
device. If the source file is a descendant of another branch, it will
be rejected too.
<P>
After mounting aufs or adding a branch, if you move a branch under
another branch and make it descendant of another branch, aufs will not
work correctly.
<DT><B>[ add | ins ]:index:BRANCH</B>

<DD>
Adds a new branch.
The index begins with 0.
Aufs creates
whiteout-base(AUFS_WH_BASE]) and
whplink-dir(AUFS_WH_PLINKDIR]) if necessary.
<P>
If there is the same named file on the lower branch (larger index),
aufs will hide the lower file.
You can only see the highest file.
You will be confused if the added branch has whiteouts (including
diropq), they may or may not hide the lower entries.

<P>
Even if a process have once mapped a file by <A HREF="http://localhost/cgi-bin/man/man2html?2+mmap">mmap</A>(2) with MAP_SHARED
and the same named file exists on the lower branch,
the process still refers the file on the lower(hidden)
branch after adding the branch.
If you want to update the contents of a process address space after
adding, you need to restart your process or open/mmap the file again.

(cf. Branch Syntax).
<DT><B>del:dir</B>

<DD>
Removes a branch.
Aufs does not remove
whiteout-base(AUFS_WH_BASE]) and
whplink-dir(AUFS_WH_PLINKDIR]) automatically.
For example, when you add a RO branch which was unified as RW, you
will see whiteout-base or whplink-dir on the added RO branch.
<P>
If a process is referencing the file/directory on the deleting branch
(by open, mmap, current working directory, etc.), aufs will return an
error EBUSY.
<DT><B>mod:BRANCH</B>

<DD>
Modifies the permission flags of the branch.
Aufs creates or removes
whiteout-base(AUFS_WH_BASE]) and/or
whplink-dir(AUFS_WH_PLINKDIR]) if necessary.
<P>
If the branch permission is been changing [oq]rw[cq] to [oq]ro[cq], and a process
is mapping a file by <A HREF="http://localhost/cgi-bin/man/man2html?2+mmap">mmap</A>(2)

on the branch, the process may or may not
be able to modify its mapped memory region after modifying branch
permission flags.
Additioanlly when you enable CONFIG_IMA (in linux-2.6.30 and later), IMA
may produce some wrong messages. But this is equivalent when the
filesystem is changed [oq]ro[cq] in emergency.
(cf. Branch Syntax).
<DT><B>append:BRANCH</B>

<DD>
equivalent to [oq]add:(last index + 1):BRANCH[cq].
(cf. Branch Syntax).
<DT><B>prepend:BRANCH</B>

<DD>
equivalent to [oq]add:0:BRANCH.[cq]
(cf. Branch Syntax).
<DT><B>xino=filename</B>

<DD>
Use external inode number bitmap and translation table.
When CONFIG_AUFS_EXPORT is enabled, external inode generation table too.
It is set to
&lt;FirstWritableBranch&gt;/AUFS_XINO_FNAME] by default, or
AUFS_XINO_DEFPATH].
Comma character in filename is not allowed.
<P>
The files are created per an aufs and per a branch filesystem, and
unlinked. So you
cannot find this file, but it exists and is read/written frequently by
aufs.
(cf. External Inode Number Bitmap, Translation Table and Generation Table).
<P>
If you enable CONFIG_SYSFS, the path of xino files are not shown in
/proc/mounts (and /etc/mtab), instead it is shown in
&lt;sysfs&gt;/fs/aufs/si_&lt;id&gt;/xi_path.
Otherwise, it is shown in /proc/mounts unless it is not the default
path.
<DT><B>noxino</B>

<DD>
Stop using external inode number bitmap and translation table.
<P>
If you use this option,
Some applications will not work correctly.


(cf. External Inode Number Bitmap, Translation Table and Generation Table).
<DT><B>trunc_xib</B>

<DD>
Truncate the external inode number bitmap file. The truncation is done
automatically when you delete a branch unless you do not specify
[oq]notrunc_xib[cq] option.
(cf. External Inode Number Bitmap, Translation Table and Generation Table).
<DT><B>notrunc_xib</B>

<DD>
Stop truncating the external inode number bitmap file when you delete
a branch.
(cf. External Inode Number Bitmap, Translation Table and Generation Table).
<DT><B>create_policy | create=CREATE_POLICY</B>

<DD>

<BR>


<DT>

<B>copyup_policy | copyup | cpup=COPYUP_POLICY</B>

<DD>Policies to select one among multiple writable branches. The default
values are [oq]create=tdp[cq] and [oq]cpup=tdp[cq].
<A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) systemcalls have an exception. In aufs, they
try keeping their operations in the branch where the source exists.
(cf. Policies to Select One among Multiple Writable Branches).
<DT><B>verbose | v</B>

<DD>
Print some information.
Currently, it is only busy file (or inode) at deleting a branch.
<DT><B>noverbose | quiet | q | silent</B>

<DD>
Disable [oq]verbose[cq] option.
This is default value.
<DT><B>sum</B>

<DD>
<A HREF="http://localhost/cgi-bin/man/man2html?1+df">df</A>(1)/<A HREF="http://localhost/cgi-bin/man/man2html?2+statfs">statfs</A>(2) returns the total number of blocks and inodes of
all branches.
Note that there are cases that systemcalls may return ENOSPC, even if
<A HREF="http://localhost/cgi-bin/man/man2html?1+df">df</A>(1)/<A HREF="http://localhost/cgi-bin/man/man2html?2+statfs">statfs</A>(2) shows that aufs has some free space/inode.
<DT><B>nosum</B>

<DD>
Disable [oq]sum[cq] option.
This is default value.
<DT><B>dirwh=N</B>

<DD>
Watermark to remove a dir actually at <A HREF="http://localhost/cgi-bin/man/man2html?2+rmdir">rmdir</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2).
<P>
If the target dir which is being removed or renamed (destination dir)
has a huge number of whiteouts, i.e. the dir is empty logically but
physically, the cost to remove/rename the single
dir may be very high.
It is
required to unlink all of whiteouts internally before issuing
rmdir/rename to the branch.
To reduce the cost of single systemcall,
aufs renames the target dir to a whiteout-ed temporary name and
invokes a pre-created
kernel thread to remove whiteout-ed children and the target dir.
The rmdir/rename systemcall returns just after kicking the thread.
<P>
When the number of whiteout-ed children is less than the value of
dirwh, aufs remove them in a single systemcall instead of passing
another thread.
This value is ignored when the branch is NFS.
The default value is AUFS_DIRWH_DEF].



<DT><B>rdblk=N</B>

<DD>
Specifies a size of internal VDIR block which is allocated at a time in
byte.
The VDIR block will be allocated several times when necessary. If your
directory has millions of files, you may want to expand this size.
The default value is defined as AUFS_RDBLK_DEF].
The size has to be lager than NAME_MAX (usually 255) and kmalloc-able
(the maximum limit depends on your system. at least 128KB is available
for every system).
If you set it to zero, then the internal estimation for the directory
size becomes ON, and aufs sets the value for the directory individually.
Sometimes the estimated value may be inappropriate since the estimation
is not so clever. Setting zero is useful when you use RDU
(cf. VDIR/<A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) in user-space (RDU).
Otherwise it may be a pressure for kernel memory space.
Anytime you can reset the value to default by specifying rdblk=def.
(cf. Virtual or Vertical Directory Block).
<DT><B>rdhash=N</B>

<DD>
Specifies a size of internal VDIR hash table which is used to compare
the file names under the same named directory on multiple branches.
The VDIR hash table will be allocated in <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3)/<A HREF="http://localhost/cgi-bin/man/man2html?2+getdents">getdents</A>(2),
<A HREF="http://localhost/cgi-bin/man/man2html?2+rmdir">rmdir</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) for the existing target directory. If your
directory has millions of files, you may want to expand this size.
The default value is defined as AUFS_RDHASH_DEF].
The size has to be lager than zero, and it will be multiplied by 4 or 8
(for 32-bit and 64-bit respectively, currently). The result must be
kmalloc-able
(the maximum limit depends on your system. at least 128KB is available
for every system).
If you set it to zero, then the internal estimation for the directory
becomes ON, and aufs sets the value for the directory individually.
Sometimes the estimated value may be inappropriate since the estimation
is not so clever. Setting zero is useful when you use RDU
(cf. VDIR/<A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) in user-space (RDU).
Otherwise it may be a pressure for kernel memory space.
Anytime you can reset the value to default by specifying rdhash=def.
(cf. Virtual or Vertical Directory Block).
<DT><B>plink</B>

<DD>

<BR>


<DT>

<B>noplink</B>

<DD>Specifies to use [oq]pseudo link[cq] feature or not.
The default is [oq]plink[cq] which means use this feature.
(cf. Pseudo Link)
<DT><B>clean_plink</B>

<DD>
Removes all pseudo-links in memory.
In order to make pseudo-link permanent, use
[oq]auplink[cq] utility just before one of these operations,
unmounting aufs,
using [oq]ro[cq] or [oq]noplink[cq] mount option,
deleting a branch from aufs,
adding a branch into aufs,
or changing your writable branch as readonly.
If you installed both of /sbin/mount.aufs and /sbin/umount.aufs, and your
<A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) and <A HREF="http://localhost/cgi-bin/man/man2html?8+umount">umount</A>(8) support them,
[oq]auplink[cq] utility will be executed automatically and flush pseudo-links.
(cf. Pseudo Link)
<DT><B>udba=none | reval | inotify</B>

<DD>
Specifies the level of UDBA (User[aq]s Direct Branch Access) test.
(cf. User[aq]s Direct Branch Access and Inotify Limitation).
<DT><B>diropq=whiteouted | w | always | a</B>

<DD>
Specifies whether <A HREF="http://localhost/cgi-bin/man/man2html?2+mkdir">mkdir</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) dir case make the created directory
[oq]opaque[cq] or not.
In other words, to create [oq]AUFS_WH_DIROPQ][cq] under the created or renamed
directory, or not to create.
When you specify diropq=w or diropq=whiteouted, aufs will not create
it if the
directory was not whiteouted or opaqued. If the directory was whiteouted
or opaqued, the created or renamed directory will be opaque.
When you specify diropq=a or diropq==always, aufs will always create
it regardless
the directory was whiteouted/opaqued or not.
The default value is diropq=w, it means not to create when it is unnecessary.
If you define CONFIG_AUFS_COMPAT at aufs compiling time, the default will be
diropq=a.
You need to consider this option if you are planning to add a branch later
since [oq]diropq[cq] affects the same named directory on the added branch.
<DT><B>warn_perm</B>

<DD>

<BR>


<DT>

<B>nowarn_perm</B>

<DD>Adding a branch, aufs will issue a warning about uid/gid/permission of
the adding branch directory,
when they differ from the existing branch[aq]s. This difference may or
may not impose a security risk.
If you are sure that there is no problem and want to stop the warning,
use [oq]nowarn_perm[cq] option.
The default is [oq]warn_perm[cq] (cf. DIAGNOSTICS).
<DT><B>shwh</B>

<DD>

<BR>


<DT>

<B>noshwh</B>

<DD>By default (noshwh), aufs doesn[aq]t show the whiteouts and
they just hide the same named entries in the lower branches. The
whiteout itself also never be appeared.
If you enable CONFIG_AUFS_SHWH and specify [oq]shwh[cq] option, aufs
will show you the name of whiteouts
with keeping its feature to hide the lowers.
Honestly speaking, I am rather confused with this [oq]visible whiteouts.[cq]
But a user who originally requested this feature wrote a nice how-to
document about this feature. See Tips file in the aufs CVS tree.
<P>

</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>Module Parameters</H2>

<DL COMPACT>
<DT><B>nwkq=N</B>

<DD>
The number of kernel thread named AUFS_WKQ_NAME].
<P>
Those threads stay in the system while the aufs module is loaded,
and handle the special I/O requests from aufs.
The default value is AUFS_NWKQ_DEF].
<P>
The special I/O requests from aufs include a part of copy-up, lookup,
directory handling, pseudo-link, xino file operations and the
delegated access to branches.
For example, Unix filesystems allow you to <A HREF="http://localhost/cgi-bin/man/man2html?2+rmdir">rmdir</A>(2) which has no write
permission bit, if its parent directory has write permission bit. In aufs, the
removing directory may or may not have whiteout or [oq]dir opaque[cq] mark as its
child. And aufs needs to <A HREF="http://localhost/cgi-bin/man/man2html?2+unlink">unlink</A>(2) them before <A HREF="http://localhost/cgi-bin/man/man2html?2+rmdir">rmdir</A>(2).
Therefore aufs delegates the actual <A HREF="http://localhost/cgi-bin/man/man2html?2+unlink">unlink</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rmdir">rmdir</A>(2) to another kernel
thread which has been created already and has a superuser privilege.
<P>
If you enable CONFIG_SYSFS, you can check this value through
&lt;sysfs&gt;/module/aufs/parameters/nwkq.
<P>
<DT><B>brs=1 | 0</B>

<DD>
Specifies to use the branch path data file under sysfs or not.
<P>
If the number of your branches is large or their path is long
and you meet the limitation of <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) ro /etc/mtab, you need to
enable CONFIG_SYSFS and set aufs module parameter brs=1.
<P>
When this parameter is set as 1, aufs does not show [oq]br:[cq] (or dirs=)
mount option through /proc/mounts (and /etc/mtab). So you can
keep yourself from the page limitation of
<A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) or /etc/mtab.
Aufs shows branch paths through &lt;sysfs&gt;/fs/aufs/si_XXX/brNNN.
Actually the file under sysfs has also a size limitation, but I don[aq]t
think it is harmful.
<P>
There is one more side effect in setting 1 to this parameter.
If you rename your branch, the branch path written in /etc/mtab will be
obsoleted and the future remount will meet some error due to the
unmatched parameters (Remember that <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) may take the options from
/etc/mtab and pass them to the systemcall).
If you set 1, /etc/mtab will not hold the branch path and you will not
meet such trouble. On the other hand, the entries for the
branch path under sysfs are generated dynamically. So it must not be obsoleted.
But I don[aq]t think users want to rename branches so often.
<P>
If CONFIG_SYSFS is disable, this parameter is always set to 0.
<DT><B>sysrq=key</B>

<DD>
Specifies MagicSysRq key for debugging aufs.
You need to enable both of CONFIG_MAGIC_SYSRQ and CONFIG_AUFS_DEBUG.
Currently this is for developers only.
The default is [oq]a[cq].
<DT><B>debug= 0 | 1</B>

<DD>
Specifies disable(0) or <A HREF="http://localhost/cgi-bin/man/man2html?1+enable">enable</A>(1) debug print in aufs.
This parameter can be changed dynamically.
You need to enable CONFIG_AUFS_DEBUG.
Currently this is for developers only.
The default is [oq]0[cq] (disable).
<P>

</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>Entries under Sysfs and Debugfs</H2>

See linux/Documentation/ABI/*/{sys,debug}fs-aufs.
<P>

<A NAME="lbAG">&nbsp;</A>
<H2>Branch Syntax</H2>

<DL COMPACT>
<DT><B>dir_path[ =permission [ + attribute ] ]</B>

<DD>

<BR>


<DT>

<B>permission := rw | ro | rr</B>


<DD>

<DT>

<B>attribute := wh | nolwh</B>

<DD>dir_path is a directory path.
The keyword after [oq]dir_path=[cq] is a
permission flags for that branch.
Comma, colon and the permission flags string (including [oq]=[cq])in the path
are not allowed.
<P>
Any filesystem can be a branch, But some are not accepted such like
sysfs, procfs and unionfs.
If you specify such filesystems as an aufs branch, aufs will return an error
saying it is unsupported.
<P>
Cramfs in linux stable release has strange inodes and it makes aufs
confused. For example,
<PRE>
$ mkdir -p w/d1 w/d2
$ &gt; w/z1
$ &gt; w/z2
$ mkcramfs w cramfs
$ sudo mount -t cramfs -o ro,loop cramfs /mnt
$ find /mnt -ls
    76    1 drwxr-xr-x   1 jro      232            64 Jan  1  1970 /mnt
     1    1 drwxr-xr-x   1 jro      232             0 Jan  1  1970 /mnt/d1
     1    1 drwxr-xr-x   1 jro      232             0 Jan  1  1970 /mnt/d2
     1    1 -rw-r--r--   1 jro      232             0 Jan  1  1970 /mnt/z1
     1    1 -rw-r--r--   1 jro      232             0 Jan  1  1970 /mnt/z2
</PRE>

<P>
All these two directories and two files have the same inode with one
as their link count. Aufs cannot handle such inode correctly.
Currently, aufs involves a tiny workaround for such inodes. But some
applications may not work correctly since aufs inode number for such
inode will change silently.
If you do not have any empty files, empty directories or special files,
inodes on cramfs will be all fine.
<P>
A branch should not be shared as the writable branch between multiple
aufs. A readonly branch can be shared.
<P>
The maximum number of branches is configurable at compile time (127 by
default).
<P>
When an unknown permission or attribute is given, aufs sets ro to that
branch silently.
<P>
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>Permission</H3>

<DL COMPACT>
<DT><B>rw</B>

<DD>
Readable and writable branch. Set as default for the first branch.
If the branch filesystem is mounted as readonly, you cannot set it [oq]rw.[cq]


<DT><B>ro</B>

<DD>
Readonly branch and it has no whiteouts on it.
Set as default for all branches except the first one. Aufs never issue
both of write operation and lookup operation for whiteout to this branch.
<DT><B>rr</B>

<DD>
Real readonly branch, special case of [oq]ro[cq], for natively readonly
branch. Assuming the branch is natively readonly, aufs can optimize
some internal operation. For example, if you specify [oq]udba=inotify[cq]
option, aufs does not set inotify for the things on rr branch.
Set by default for a branch whose fs-type is either [oq]iso9660[cq],
[oq]cramfs[cq] or [oq]romfs[cq] (and [oq]squashfs[cq] for linux-2.6.29 and later).
<P>
When your branch exists on slower device and you have some
capacity on your hdd, you may want to try ulobdev tool in ULOOP sample.
It can cache the contents of the real devices on another faster device,
so you will be able to get the better access performance.
The ulobdev tool is for a generic block device, and the ulohttp is for a
filesystem image on http server.
If you want to spin down your hdd to save the
battery life or something, then you may want to use ulobdev to save the
access to the hdd, too.
See $AufsCVS/sample/uloop in detail.
<P>
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>Attribute</H3>

<DL COMPACT>
<DT><B>wh</B>

<DD>
Readonly branch and it has/might have whiteouts on it.
Aufs never issue write operation to this branch, but lookup for whiteout.
Use this as [oq]&lt;branch_dir&gt;=ro+wh[cq].
<DT><B>nolwh</B>

<DD>
Usually, aufs creates a whiteout as a hardlink on a writable
branch. This attributes prohibits aufs to create the hardlinked
whiteout, including the source file of all hardlinked whiteout
(AUFS_WH_BASE].)
If you do not like a hardlink, or your writable branch does not support
<A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2), then use this attribute.
But I am afraid a filesystem which does not support <A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2) natively
will fail in other place such as copy-up.
Use this as [oq]&lt;branch_dir&gt;=rw+nolwh[cq].
Also you may want to try [oq]noplink[cq] mount option, while it is not recommended.
<P>
































































<P>

</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>External Inode Number Bitmap, Translation Table and Generation Table (xino)</H2>

Aufs uses one external bitmap file and one external inode number
translation table files per an aufs and per a branch
filesystem by default.
Additionally when CONFIG_AUFS_EXPORT is enabled, one external inode
generation table is added.
The bitmap (and the generation table) is for recycling aufs inode number
and the others
are a table for converting an inode number on a branch to
an aufs inode number. The default path
is [oq]first writable branch[cq]/AUFS_XINO_FNAME].
If there is no writable branch, the
default path
will be AUFS_XINO_DEFPATH].


<P>
If you enable CONFIG_SYSFS, the path of xino files are not shown in
/proc/mounts (and /etc/mtab), instead it is shown in
&lt;sysfs&gt;/fs/aufs/si_&lt;id&gt;/xi_path.
Otherwise, it is shown in /proc/mounts unless it is not the default
path.
<P>
Those files are always opened and read/write by aufs frequently.
If your writable branch is on flash memory device, it is recommended
to put xino files on other than flash memory by specifying [oq]xino=[cq]
mount option.
<P>
The
maximum file size of the bitmap is, basically, the amount of the
number of all the files on all branches divided by 8 (the number of
bits in a byte).
For example, on a 4KB page size system, if you have 32,768 (or
2,599,968) files in aufs world,
then the maximum file size of the bitmap is 4KB (or 320KB).
<P>
The
maximum file size of the table will
be [oq]max inode number on the branch x size of an inode number[cq].
For example in 32bit environment,
<P>
<PRE>
$ df -i /branch_fs
/dev/hda14           2599968  203127 2396841    8% /branch_fs
</PRE>

<P>
and /branch_fs is an branch of the aufs. When the inode number is
assigned contiguously (without [oq]hole[cq]), the maximum xino file size for
/branch_fs will be 2,599,968 x 4 bytes = about 10 MB. But it might not be
allocated all of disk blocks.
When the inode number is assigned discontinuously, the maximum size of
xino file will be the largest inode number on a branch x 4 bytes.
Additionally, the file size is limited to LLONG_MAX or the s_maxbytes
in filesystem[aq]s superblock (s_maxbytes may be smaller than
LLONG_MAX). So the
support-able largest inode number on a branch is less than
2305843009213693950 (LLONG_MAX/4-1).
This is the current limitation of aufs.
On 64bit environment, this limitation becomes more strict and the
supported largest inode number is less than LLONG_MAX/8-1.
<P>
The xino files are always hidden, i.e. removed. So you cannot
do [oq]ls -l xino_file[cq].
If you enable CONFIG_DEBUG_FS, you can check these information through
&lt;debugfs&gt;/aufs/&lt;si_id&gt;/{xib,xi[0-9]*,xigen}. xib is for the bitmap file,
xi0 ix for the first branch, and xi1 is for the next. xigen is for the
generation table.
xib and xigen are in the format of,
<P>
<PRE>
&lt;blocks&gt;x&lt;block size&gt; &lt;file size&gt;
</PRE>

<P>
Note that a filesystem usually has a
feature called pre-allocation, which means a number of
blocks are allocated automatically, and then deallocated
silently when the filesystem thinks they are unnecessary.
You do not have to be surprised the sudden changes of the number of
blocks, when your filesystem which xino files are placed supports the
pre-allocation feature.
<P>
The rests are hidden xino file information in the format of,
<P>
<PRE>
&lt;file count&gt;, &lt;blocks&gt;x&lt;block size&gt; &lt;file size&gt;
</PRE>

<P>
If the file count is larger than 1, it means some of your branches are
on the same filesystem and the xino file is shared by them.
Note that the file size may not be equal to the actual consuming blocks
since xino file is a sparse file, i.e. a hole in a file which does not
consume any disk blocks.
<P>
Once you unmount aufs, the xino files for that aufs are totally gone.
It means that the inode number is not permanent across umount or
shutdown.
<P>
The xino files should be created on the filesystem except NFS.
If your first writable branch is NFS, you will need to specify xino
file path other than NFS.
Also if you are going to remove the branch where xino files exist or
change the branch permission to readonly, you need to use xino option
before del/mod the branch.
<P>
The bitmap file can be truncated.
For example, if you delete a branch which has huge number of files,
many inode numbers will be recycled and the bitmap will be truncated
to smaller size. Aufs does this automatically when a branch is
deleted.
You can truncate it anytime you like if you specify [oq]trunc_xib[cq] mount
option. But when the accessed inode number was not deleted, nothing
will be truncated.
If you do not want to truncate it (it may be slow) when you delete a
branch, specify [oq]notrunc_xib[cq] after [oq]del[cq] mount option.
<P>
If you do not want to use xino, use noxino mount option. Use this
option with care, since the inode number may be changed silently and
unexpectedly anytime.
For example,
rmdir failure, recursive chmod/chown/etc to a large and deep directory
or anything else.
And some applications will not work correctly.


If you want to change the xino default path, use xino mount option.
<P>
After you add branches, the persistence of inode number may not be
guaranteed.
At remount time, cached but unused inodes are discarded.
And the newly appeared inode may have different inode number at the
next access time. The inodes in use have the persistent inode number.
<P>
When aufs assigned an inode number to a file, and if you create the
same named file on the upper branch directly, then the next time you
access the file, aufs may assign another inode number to the file even
if you use xino option.
Some applications may treat the file whose inode number has been
changed as totally different file.
<P>

<A NAME="lbAK">&nbsp;</A>
<H2>Pseudo Link (hardlink over branches)</H2>

Aufs supports [oq]pseudo link[cq] which is a logical hard-link over
branches (cf. <A HREF="http://localhost/cgi-bin/man/man2html?1+ln">ln</A>(1) and <A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2)).
In other words, a copied-up file by <A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2) and a copied-up file which was
hard-linked on a readonly branch filesystem.
<P>
When you have files named fileA and fileB which are
hardlinked on a readonly branch, if you write something into fileA,
aufs copies-up fileA to a writable branch, and <A HREF="http://localhost/cgi-bin/man/man2html?2+write">write</A>(2) the originally
requested thing to the copied-up fileA. On the writable branch,
fileA is not hardlinked.
But aufs remembers it was hardlinked, and handles fileB as if it existed
on the writable branch, by referencing  fileA[aq]s inode on the writable
branch as fileB[aq]s inode.
<P>
Once you unmount aufs, the plink info for that aufs kept in memory are totally
gone.
It means that the pseudo-link is not permanent.
If you want to make plink permanent, try [oq]auplink[cq] utility just before
one of these operations,
unmounting your aufs,
using [oq]ro[cq] or [oq]noplink[cq] mount option,
deleting a branch from aufs,
adding a branch into aufs,
or changing your writable branch to readonly.
<P>
This utility will reproduces all real hardlinks on a writable branch by linking
them, and removes pseudo-link info in memory and temporary link on the
writable branch.
Since this utility access your branches directly, you cannot hide them by
[oq]mount --bind /tmp /branch[cq] or something.
<P>
If you are willing to rebuild your aufs with the same branches later, you
should use auplink utility before you umount your aufs.
If you installed both of /sbin/mount.aufs and /sbin/umount.aufs, and your
<A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) and <A HREF="http://localhost/cgi-bin/man/man2html?8+umount">umount</A>(8) support them,
[oq]auplink[cq] utility will be executed automatically and flush pseudo-links.
<P>
<PRE>
# auplink /your/aufs/root flush
# umount /your/aufs/root
or
# auplink /your/aufs/root flush
# mount -o remount,mod:/your/writable/branch=ro /your/aufs/root
or
# auplink /your/aufs/root flush
# mount -o remount,noplink /your/aufs/root
or
# auplink /your/aufs/root flush
# mount -o remount,del:/your/aufs/branch /your/aufs/root
or
# auplink /your/aufs/root flush
# mount -o remount,append:/your/aufs/branch /your/aufs/root
</PRE>

<P>
The plinks are kept both in memory and on disk. When they consumes too much
resources on your system, you can use the [oq]auplink[cq] utility at anytime and
throw away the unnecessary pseudo-links in safe.
<P>
Additionally, the [oq]auplink[cq] utility is very useful for some security reasons.
For example, when you have a directory whose permission flags
are 0700, and a file who is 0644 under the 0700 directory. Usually,
all files under the 0700 directory are private and no one else can see
the file. But when the directory is 0711 and someone else knows the 0644
filename, he can read the file.
<P>
Basically, aufs pseudo-link feature creates a temporary link under the
directory whose owner is root and the permission flags are 0700.
But when the writable branch is NFS, aufs sets 0711 to the directory.
When the 0644 file is pseudo-linked, the temporary link, of course the
contents of the file is totally equivalent, will be created under the
0711 directory. The filename will be generated by its inode number.
While it is hard to know the generated filename, someone else may try peeping
the temporary pseudo-linked file by his software tool which may try the name
from one to MAX_INT or something.
In this case, the 0644 file will be read unexpectedly.
I am afraid that leaving the temporary pseudo-links can be a security hole.
It makes sense to execute [oq]auplink /your/aufs/root flush[cq]
periodically, when your writable branch is NFS.
<P>
When your writable branch is not NFS, or all users are careful enough to set 0600
to their private files, you do not have to worry about this issue.
<P>
If you do not want this feature, use [oq]noplink[cq] mount option.
<P>
<A NAME="lbAL">&nbsp;</A>
<H3>The behaviours of plink and noplink</H3>

This sample shows that the [oq]f_src_linked2[cq] with [oq]noplink[cq] option cannot follow
the link.
<P>
<PRE>
none on /dev/shm/u type aufs (rw,xino=/dev/shm/rw/.aufs.xino,br:/dev/shm/rw=rw:/dev/shm/ro=ro)
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
ls: ./copied: No such file or directory
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
22 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked
22 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked2
$ echo abc &gt;&gt; f_src_linked
$ cp f_src_linked copied
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
36 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ../rw/f_src_linked
53 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ./copied
22 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked
22 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked2
$ cmp copied f_src_linked2
$

none on /dev/shm/u type aufs (rw,xino=/dev/shm/rw/.aufs.xino,noplink,br:/dev/shm/rw=rw:/dev/shm/ro=ro)
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
ls: ./copied: No such file or directory
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
23 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked
23 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked2
$ echo abc &gt;&gt; f_src_linked
$ cp f_src_linked copied
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
36 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ../rw/f_src_linked
53 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ./copied
23 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked
23 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked2
$ cmp copied f_src_linked2
cmp: EOF on f_src_linked2
$
</PRE>

<P>








<P>
If you add a branch which has fileA or fileB, aufs does not follow the
pseudo link. The file on the added branch has no relation to the same
named file(s) on the lower branch(es).
If you use noxino mount option, pseudo link will not work after the
kernel shrinks the inode cache.
<P>
This feature will not work for squashfs before version 3.2 since its
inode is tricky.
When the inode is hardlinked, squashfs inodes has the same inode
number and correct link count, but the inode memory object is
different. Squashfs inodes (before v3.2) are generated for each, even
they are hardlinked.
<P>

<A NAME="lbAM">&nbsp;</A>
<H2>User[aq]s Direct Branch Access (UDBA)</H2>

UDBA means a modification to a branch filesystem manually or directly,
e.g. bypassing aufs.
While aufs is designed and implemented to be safe after UDBA,
it can make yourself and your aufs confused. And some information like
aufs inode will be incorrect.
For example, if you rename a file on a branch directly, the file on
aufs may
or may not be accessible through both of old and new name.
Because aufs caches various information about the files on
branches. And the cache still remains after UDBA.
<P>
Aufs has a mount option named [oq]udba[cq] which specifies the test level at
access time whether UDBA was happened or not.
<DL COMPACT>
<DT><B>udba=none</B>

<DD>
Aufs trusts the dentry and the inode cache on the system, and never
test about UDBA. With this option, aufs runs fastest, but it may show
you incorrect data.
Additionally, if you often modify a branch
directly, aufs will not be able to trace the changes of inodes on the
branch. It can be a cause of wrong behaviour, deadlock or anything else.
<P>
It is recommended to use this option only when you are sure that
nobody access a file on a branch.
It might be difficult for you to achieve real [oq]no UDBA[cq] world when you
cannot stop your users doing [oq]find / -ls[cq] or something.
If you really want to forbid all of your users to UDBA, here is a trick
for it.
With this trick, users cannot see the
branches directly and aufs runs with no problem, except [oq]auplink[cq] utility.
But if you are not familiar with aufs, this trick may make
yourself confused.
<P>
<PRE>
# d=/tmp/.aufs.hide
# mkdir $d
# for i in $branches_you_want_to_hide
&gt; do
&gt;       mount -n --bind $d $i
&gt; done
</PRE>

<P>
When you unmount the aufs, delete/modify the branch by remount, or you
want to show the hidden branches again, unmount the bound
/tmp/.aufs.hide.
<P>
<PRE>
# umount -n $branches_you_want_to_unbound
</PRE>

<P>
If you use FUSE filesystem as an aufs branch which supports hardlink,
you should not set this option, since FUSE makes inode objects for
each hardlinks (at least in linux-2.6.23). When your FUSE filesystem
maintains them at link/unlinking, it is equivalent
to [oq]direct branch access[cq] for aufs.
<P>
<DT><B>udba=reval</B>

<DD>
Aufs tests only the existence of the file which existed. If
the existed file was removed on the branch directly, aufs
discard the cache about the file and
re-lookup it. So the data will be updated.
This test is at minimum level to keep the performance and ensure the
existence of a file.
This is default and aufs runs still fast.
<P>
This rule leads to some unexpected situation, but I hope it is
harmless. Those are totally depends upon cache. Here are just a few
examples.
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>*<DD>

If the file is cached as negative or
not-existed, aufs does not test it. And the file is still handled as
negative after a user created the file on a branch directly. If the
file is not cached, aufs will lookup normally and find the file.

<DT>*<DD>

When the file is cached as positive or existed, and a user created the
same named file directly on the upper branch. Aufs detects the cached
inode of the file is still existing and will show you the old (cached)
file which is on the lower branch.

<DT>*<DD>

When the file is cached as positive or existed, and a user renamed the
file by <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) directly. Aufs detects the inode of the file is
still existing. You may or may not see both of the old and new files.
Todo: If aufs also tests the name, we can detect this case.
</DL>
</DL>

<P>
If your outer modification (UDBA) is rare and you can ignore the
temporary and minor differences between virtual aufs world and real
branch filesystem, then try this mount option.
<DT><B>udba=inotify</B>

<DD>
Aufs sets [oq]inotify[cq] to all the accessed directories on its branches
and receives the event about the dir and its children. It consumes
resources, cpu and memory. And I am afraid that the performance will be
hurt, but it is most strict test level.
There are some limitations of linux inotify, see also Inotify
Limitation.
So it is recommended to leave udba default option usually, and set it
to inotify by remount when you need it.
<P>
When a user accesses the file which was notified UDBA before, the cached data
about the file will be discarded and aufs re-lookup it. So the data will
be updated.
When an error condition occurs between UDBA and aufs operation, aufs
will return an error, including EIO.
To use this option, you need to enable CONFIG_INOTIFY and
CONFIG_AUFS_UDBA_INOTIFY.
<P>
To rename/rmdir a directory on a branch directory may reveal the same named
directory on the lower branch. Aufs tries re-lookuping the renamed
directory and the revealed directory and assigning different inode
number to them. But the inode number including their children can be a
problem. The inode numbers will be changed silently, and
aufs may produce a warning. If you rename a directory repeatedly and
reveal/hide the lower directory, then aufs may confuse their inode
numbers too. It depends upon the system cache.
<P>
When you make a directory in aufs and mount other filesystem on it,
the directory in aufs cannot be removed expectedly because it is a
mount point. But the same named directory on the writable branch can
be removed, if someone wants. It is just an empty directory, instead
of a mount point.
Aufs cannot stop such direct rmdir, but produces a warning about it.
<P>
If the pseudo-linked file is hardlinked or unlinked on the branch
directly, its inode link count in aufs may be incorrect. It is
recommended to flush the pseudo-links by auplink script.
<P>

</DL>
<A NAME="lbAN">&nbsp;</A>
<H2>Linux Inotify Limitation</H2>

Unfortunately, current inotify (linux-2.6.18) has some limitations,
and aufs must derive it.
<P>
<A NAME="lbAO">&nbsp;</A>
<H3>IN_ATTRIB, updating atime</H3>

When a file/dir on a branch is accessed directly, the inode atime (access
time, cf. <A HREF="http://localhost/cgi-bin/man/man2html?2+stat">stat</A>(2)) may or may not be updated. In some cases, inotify
does not fire this event. So the aufs inode atime may remain old.
<P>
<A NAME="lbAP">&nbsp;</A>
<H3>IN_ATTRIB, updating nlink</H3>

When the link count of a file on a branch is incremented by <A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2)
directly,
inotify fires IN_CREATE to the parent
directory, but IN_ATTRIB to the file. So the aufs inode nlink may
remain old.
<P>
<A NAME="lbAQ">&nbsp;</A>
<H3>IN_DELETE, removing file on NFS</H3>

When a file on a NFS branch is deleted directly, inotify may or may
not fire
IN_DELETE event. It depends upon the status of dentry
(DCACHE_NFSFS_RENAMED flag).
In this case, the file on aufs seems still exists. Aufs and any user can see
the file.
<P>
<A NAME="lbAR">&nbsp;</A>
<H3>IN_IGNORED, deleted rename target</H3>

When a file/dir on a branch is unlinked by <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) directly, inotify
fires IN_IGNORED which means the inode is deleted. Actually, in some
cases, the inode survives. For example, the rename target is linked or
opened. In this case, inotify watch set by aufs is removed by VFS and
inotify.
And aufs cannot receive the events anymore. So aufs may show you
incorrect data about the file/dir.
<P>

<A NAME="lbAS">&nbsp;</A>
<H2>Virtual or Vertical Directory Block (VDIR)</H2>

In order to provide the merged view of file listing, aufs builds
internal directory block on memory. For readdir, aufs performs readdir()
internally for each dir on branches, merges their entries with
eliminating the whiteout-ed ones, and sets it to the opened file (dir)
object. So the file object has its entry list until it is closed. The
entry list will be updated when the file position is zero (by
<A HREF="http://localhost/cgi-bin/man/man2html?3+rewinddir">rewinddir</A>(3)) and becomes obsoleted.
<P>
Some people may call it can be a security hole or invite DoS attack
since the opened and once readdir-ed dir (file object) holds its entry
list and becomes a pressure for system memory. But I would say it is similar
to files under /proc or /sys. The virtual files in them also holds a
memory page (generally) while they are opened. When an idea to reduce
memory for them is introduced, it will be applied to aufs too.
<P>
The dynamically allocated memory block for the name of entries has a
unit of AUFS_RDBLK_DEF] bytes by default.
During building dir blocks, aufs creates hash list (hashed and divided by
AUFS_RDHASH_DEF] by default) and judging whether
the entry is whiteouted by its upper branch or already listed.
<P>
These values are suitable for normal environments. But you may have
millions of files or very long filenames under a single directory. For
such cases, you may need to customize these values by specifying rdblk=
and rdhash= aufs mount options.
<P>
For instance, there are 97 files under my /bin, and the total name
length is 597 bytes.
<P>
<PRE>
$ \ls -1 /bin | wc
     97      97     597
</PRE>

<P>
Strictly speaking, 97 end-of-line codes are
included. But it is OK since aufs VDIR also stores the name length in 1
byte. In this case, you do not need to customize the default values. 597 bytes
filenames will be stored in 2 VDIR memory blocks (597 &lt;
AUFS_RDBLK_DEF] x 2).
And 97 filenames are distributed among AUFS_RDHASH_DEF] lists, so one
list will point 4 names in average. To judge the names is whiteouted or
not, the number of comparison will be 4. 2 memory allocations
and 4 comparison costs low (even if the directory is opened for a long
time). So you do not need to customize.
<P>
If your directory has millions of files, the you will need to specify
rdblk= and rdhash=.
<P>
<PRE>
$ ls -U /mnt/rotating-rust | wc -l
1382438
</PRE>

<P>
In this case, assuming the average length of filenames is 6, in order to
get better time performance I would
recommend to set $((128*1024)) or $((64*1024)) for rdblk, and
$((8*1024)) or $((4*1024)) for rdhash.
You can change these values of the active aufs mount by &quot;mount -o
remount&quot;.
<P>
This customization is not for
reducing the memory space, but for reducing time for the number of memory
allocation and the name comparison. The larger value is faster, in
general. Of course, you will need system memory. This is a generic
&quot;time-vs-space&quot; problem.
<P>

<A NAME="lbAT">&nbsp;</A>
<H2>VDIR/<A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) in user-space (RDU)</H2>

If you have a directory which has millions of files, aufs VDIR consumes
much memory. You may meet &quot;out of memory&quot; message due to
the memory fragmentation or real starvation.
In this case, RDU (<A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) in user-space) may help you.
Because the kernel memory space cannot be swappable and consuming much
can be pure memory pressure, while it is not true in user-space.
<P>
If you enable CONFIG_AUFS_RDU at compiling aufs, and install libau.so in
aufs2-util GIT tree (by &quot;make install_ulib&quot;), then you can use RDU.
Just simply set the environment variable &quot;LD_PRELOAD=libau.so&quot;
and run your application. The dynamic link library libau.so implements
another readdir routine, and all <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) calls in your application
will be handled by libau.so.
<P>
When you call <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3), the dynamic linker calls readdir in libau.so.
If it finds the passed dir is NOT aufs, it calls the usual <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3).
It the dir is aufs, then libau.so gets all filenames under the dir by
aufs specific <A HREF="http://localhost/cgi-bin/man/man2html?2+ioctl">ioctl</A>(2)s, instead of regular <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3), and merges them
by itself.
In other words,
libau.so moves the memory consumption in kernel-space to user-space.
<P>
While it is good to stop consuming much memory in kernel-space,
sometimes the speed performance may be damaged a little as a side
effect.
It is just a little, I hope. At the same time, I won[aq]t be surprised if
<A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) runs faster.
<P>
It is recommended to specify rdblk=0 when you use this library.
<P>
If your directory is not so huge and you don[aq]t meet the out of memory
situation, probably you don[aq]t need this library. The original VDIR in
kernel-space is still alive, and you can live without libau.so.
<P>
<A NAME="lbAU">&nbsp;</A>
<H3>Note</H3>

Since this is a dynamically linked library, it is unavailable if your
application is statically linked. And <A HREF="http://localhost/cgi-bin/man/man2html?8+ld.so">ld.so</A>(8) ignores LD_PRELOAD when
the application is setuid/setgid-ed unless the library is not
setuid/setgid-ed. It is a generic rule of
dynamically linked library.
Additionally libau.so is unavailable in these cases too.
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>*<DD>

the application or library issues <A HREF="http://localhost/cgi-bin/man/man2html?2+getdents">getdents</A>(2) instead of <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3).

<DT>*<DD>

the library which implements <A HREF="http://localhost/cgi-bin/man/man2html?3+readdir">readdir</A>(3) calls it
internally. e.g. <A HREF="http://localhost/cgi-bin/man/man2html?3+scandir">scandir</A>(3).
</DL>
</DL>

<P>
<P>

<A NAME="lbAV">&nbsp;</A>
<H2>Copy On Write, or aufs internal copyup and copydown</H2>

Every stackable filesystem which implements copy-on-write supports the
copyup feature. The feature is to copy a file/dir from the lower branch
to the upper internally. When you have one readonly branch and one
upper writable branch, and you append a string to a file which exists on
the readonly branch, then aufs will copy the file from the readonly
branch to the writable branch with its directory hierarchy. It means one
<A HREF="http://localhost/cgi-bin/man/man2html?2+write">write</A>(2) involves several logical/internal <A HREF="http://localhost/cgi-bin/man/man2html?2+mkdir">mkdir</A>(2), <A HREF="http://localhost/cgi-bin/man/man2html?2+creat">creat</A>(2), <A HREF="http://localhost/cgi-bin/man/man2html?2+read">read</A>(2),
<A HREF="http://localhost/cgi-bin/man/man2html?2+write">write</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+close">close</A>(2) systemcalls
before the actual expected <A HREF="http://localhost/cgi-bin/man/man2html?2+write">write</A>(2) is performed. Sometimes it may take
a long time, particularly when the file is very large.
If CONFIG_AUFS_DEBUG is enabled, aufs produces a message saying `copying
a large file.[aq]
<P>
You may see the message when you change the xino file path or
truncate the xino/xib files. Sometimes those files can be large and may
take a long time to handle them.
<P>

<A NAME="lbAW">&nbsp;</A>
<H2>Policies to Select One among Multiple Writable Branches</H2>

Aufs has some policies to select one among multiple writable branches
when you are going to write/modify something. There are two kinds of
policies, one is for newly create something and the other is for
internal copy-up.
You can select them by specifying mount option [oq]create=CREATE_POLICY[cq]
or [oq]cpup=COPYUP_POLICY.[cq]
These policies have no meaning when you have only one writable
branch. If there is some meaning, it must hurt the performance.
<P>
<A NAME="lbAX">&nbsp;</A>
<H3>Exceptions for Policies</H3>

In every cases below, even if the policy says that the branch where a
new file should be created is /rw2, the file will be created on /rw1.

<DL COMPACT>
<DT>*<DD>

If there is a readonly branch with [oq]wh[cq] attribute above the
policy-selected branch and the parent dir is marked as opaque,
or the target (creating) file is whiteouted on the ro+wh branch, then
the policy will be ignored and the target file will be created on the
nearest upper writable branch than the ro+wh branch.
<DL COMPACT><DT><DD>
<PRE>
/aufs = /rw1 + /ro+wh/diropq + /rw2
/aufs = /rw1 + /ro+wh/wh.tgt + /rw2
</PRE>

</DL>


<DT>*<DD>

If there is a writable branch above the policy-selected branch and the
parent dir is marked as opaque or the target file is whiteouted on the
branch, then the policy will be ignored and the target file will be
created on the highest one among the upper writable branches who has
diropq or whiteout. In case of whiteout, aufs removes it as usual.
<DL COMPACT><DT><DD>
<PRE>
/aufs = /rw1/diropq + /rw2
/aufs = /rw1/wh.tgt + /rw2
</PRE>

</DL>


<DT>*<DD>

<A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) systemcalls are exceptions in every policy.
They try selecting the branch where the source exists as possible since
copyup a large file will take long time. If it can[aq]t be, ie. the
branch where the source exists is readonly, then they will follow the
copyup policy.

<DT>*<DD>

There is an exception for <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) when the target exists.
If the rename target exists, aufs compares the index of the branches
where the source and the target are existing and selects the higher
one. If the selected branch is readonly, then aufs follows the copyup
policy.
<P>
</DL>
<A NAME="lbAY">&nbsp;</A>
<H3>Policies for Creating</H3>

<DL COMPACT>
<DT><B>create=tdp | top-down-parent</B>

<DD>
Selects the highest writable branch where the parent dir exists. If
the parent dir does not exist on a writable branch, then the internal
copyup will happen. The policy for this copyup is always [oq]bottom-up.[cq]
This is the default policy.
<DT><B>create=rr | round-robin</B>

<DD>
Selects a writable branch in round robin. When you have two writable
branches and creates 10 new files, 5 files will be created for each
branch.
<A HREF="http://localhost/cgi-bin/man/man2html?2+mkdir">mkdir</A>(2) systemcall is an exception. When you create 10 new directories,
all are created on the same branch.
<DT><B>create=mfs[:second] | most-free-space[:second]</B>

<DD>
Selects a writable branch which has most free space. In order to keep
the performance, you can specify the duration ([oq]second[cq]) which makes
aufs hold the index of last selected writable branch until the
specified seconds expires. The first time you create something in aufs
after the specified seconds expired, aufs checks the amount of free
space of all writable branches by internal statfs call
and the held branch index will be updated.
The default value is AUFS_MFS_SECOND_DEF] seconds.
<DT><B>create=mfsrr:low[:second]</B>

<DD>
Selects a writable branch in most-free-space mode first, and then
round-robin mode. If the selected branch has less free space than the
specified value [oq]low[cq] in bytes, then aufs re-tries in round-robin mode.

Try an arithmetic expansion of shell which is defined by POSIX.
For example, $((10 * 1024 * 1024)) for 10M.
You can also specify the duration ([oq]second[cq]) which is equivalent to
the [oq]mfs[cq] mode.
<DT><B>create=pmfs[:second]</B>

<DD>
Selects a writable branch where the parent dir exists, such as tdp
mode. When the parent dir exists on multiple writable branches, aufs
selects the one which has most free space, such as mfs mode.
<P>
</DL>
<A NAME="lbAZ">&nbsp;</A>
<H3>Policies for Copy-Up</H3>

<DL COMPACT>
<DT><B>cpup=tdp | top-down-parent</B>

<DD>
Equivalent to the same named policy for create.
This is the default policy.
<DT><B>cpup=bup | bottom-up-parent</B>

<DD>
Selects the writable branch where the parent dir exists and the branch
is nearest upper one from the copyup-source.
<DT><B>cpup=bu | bottom-up</B>

<DD>
Selects the nearest upper writable branch from the copyup-source,
regardless the existence of the parent dir.
<P>

</DL>
<A NAME="lbBA">&nbsp;</A>
<H2>Exporting Aufs via NFS</H2>

Aufs is supporting NFS-exporting.
Since aufs has no actual block device, you need to add NFS [oq]fsid[cq] option at
exporting. Refer to the manual of NFS about the detail of this option.
<P>
There are some limitations or requirements.
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>*<DD>

The branch filesystem must support NFS-exporting.

<DT>*<DD>

NFSv2 is not supported. When you mount the exported aufs from your NFS
client, you will need to some NFS options like v3 or nfsvers=3,
especially if it is nfsroot.

<DT>*<DD>

If the size of the NFS file handle on your branch filesystem is large,
aufs will
not be able to handle it. The maximum size of NFSv3 file
handle for a filesystem is 64 bytes. Aufs uses 24 bytes for 32bit
system, plus 12 bytes for 64bit system. The rest is a room for a file
handle of a branch filesystem.

<DT>*<DD>

The External Inode Number Bitmap, Translation Table and Generation Table
(xino) is
required since NFS file
handle is based upon inode number. The mount option [oq]xino[cq] is enabled
by default.
The external inode generation table and its debugfs entry
(&lt;debugfs&gt;/aufs/si_*/xigen) is created when CONFIG_AUFS_EXPORT is
enabled even if you don[aq]t export aufs actually.
The size of the external inode generation table grows only, never be
truncated. You might need to pay attention to the free space of the
filesystem where xino files are placed. By default, it is the first
writable branch.

<DT>*<DD>

The branch filesystems must be accessible, which means [oq]not hidden.[cq]
It means you need to [oq]mount --move[cq] when you use initramfs and
<A HREF="http://localhost/cgi-bin/man/man2html?8+switch_root">switch_root</A>(8), or <A HREF="http://localhost/cgi-bin/man/man2html?8+chroot">chroot</A>(8).
</DL>
</DL>

<P>

<A NAME="lbBB">&nbsp;</A>
<H2>Dentry and Inode Caches</H2>

If you want to clear caches on your system, there are several tricks
for that. If your system ram is low,
try [oq]find /large/dir -ls &gt; /dev/null[cq].
It will read many inodes and dentries and cache them. Then old caches will be
discarded.
But when you have large ram or you do not have such large
directory, it is not effective.
<P>
If you want to discard cache within a certain filesystem,
try [oq]mount -o remount /your/mntpnt[cq]. Some filesystem may return an error of
EINVAL or something, but VFS discards the unused dentry/inode caches on the
specified filesystem.
<P>

<A NAME="lbBC">&nbsp;</A>
<H2>Compatible/Incompatible with Unionfs Version 1.x Series</H2>

If you compile aufs with -DCONFIG_AUFS_COMPAT, dirs= option and =nfsro
branch permission flag are available. They are interpreted as
br: option and =ro flags respectively.
<BR>&nbsp;[oq]debug[cq],&nbsp;[oq]delete[cq],&nbsp;[oq]imap[cq]&nbsp;options&nbsp;are&nbsp;ignored&nbsp;silently.&nbsp;When&nbsp;you
compile aufs without -DCONFIG_AUFS_COMPAT, these three options are
also ignored, but a warning message is issued.
<P>
Ignoring [oq]delete[cq] option, and to keep filesystem consistency, aufs tries
writing something to only one branch in a single systemcall. It means
aufs may copyup even if the copyup-src branch is specified as writable.
For example, you have two writable branches and a large regular file
on the lower writable branch. When you issue <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) to the file on aufs,
aufs may copyup it to the upper writable branch.
If this behaviour is not what you want, then you should <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) it
on the lower branch directly.
<P>
And there is a simple shell
script [oq]unionctl[cq] under sample subdirectory, which is compatible with
<A HREF="http://localhost/cgi-bin/man/man2html?8+unionctl">unionctl</A>(8) in
Unionfs Version 1.x series, except --query action.
This script executes <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) with [oq]remount[cq] option and uses
add/del/mod aufs mount options.
If you are familiar with Unionfs Version 1.x series and want to use <A HREF="http://localhost/cgi-bin/man/man2html?8+unionctl">unionctl</A>(8), you can
try this script instead of using mount -o remount,... directly.
Aufs does not support <A HREF="http://localhost/cgi-bin/man/man2html?2+ioctl">ioctl</A>(2) interface.
This script is highly depending upon <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) in
util-linux-2.12p package, and you need to mount /proc to use this script.
If your <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) version differs, you can try modifying this
script. It is very easy.
The unionctl script is just for a sample usage of aufs remount
interface.
<P>
Aufs uses the external inode number bitmap and translation table by
default.
<P>
The default branch permission for the first branch is [oq]rw[cq], and the
rest is [oq]ro.[cq]
<P>
The whiteout is for hiding files on lower branches. Also it is applied
to stop readdir going lower branches.
The latter case is called [oq]opaque directory.[cq] Any
whiteout is an empty file, it means whiteout is just an mark.
In the case of hiding lower files, the name of whiteout is
[oq]AUFS_WH_PFX]&lt;filename&gt;.[cq]
And in the case of stopping readdir, the name is
[oq]AUFS_WH_PFX]AUFS_WH_PFX].opq[cq] or
[oq]AUFS_WH_PFX]__dir_opaque.[cq] The name depends upon your compile
configuration
CONFIG_AUFS_COMPAT.

All whiteouts are hardlinked,
including [oq]&lt;writable branch top dir&gt;/AUFS_WH_BASE].[cq]
<P>
The hardlink on an ordinary (disk based) filesystem does not
consume inode resource newly. But in linux tmpfs, the number of free
inodes will be decremented by <A HREF="http://localhost/cgi-bin/man/man2html?2+link">link</A>(2). It is recommended to specify
nr_inodes option to your tmpfs if you meet ENOSPC. Use this option
after checking by [oq]df -i.[cq]
<P>
When you rmdir or rename-to the dir who has a number of whiteouts,
aufs rename the dir to the temporary whiteouted-name like
[oq]AUFS_WH_PFX]&lt;dir&gt;.&lt;random hex&gt;.[cq] Then remove it after actual operation.
cf. mount option [oq]dirwh.[cq]
<P>

<A NAME="lbBD">&nbsp;</A>
<H2>Incompatible with an Ordinary Filesystem</H2>

<A HREF="http://localhost/cgi-bin/man/man2html?2+stat">stat</A>(2) returns the inode info from the first existence inode among
the branches, except the directory link count.
Aufs computes the directory link count larger than the exact value usually, in
order to keep UNIX filesystem semantics, or in order to shut <A HREF="http://localhost/cgi-bin/man/man2html?1+find">find</A>(1) mouth up.
The size of a directory may be wrong too, but it has to do no harm.
The timestamp of a directory will not be updated when a file is
created or removed under it, and it was done on a lower branch.
<P>
The test for permission bits has two cases. One is for a directory,
and the other is for a non-directory. In the case of a directory, aufs
checks the permission bits of all existing directories. It means you
need the correct privilege for the directories including the lower
branches.
The test for a non-directory is more simple. It checks only the
topmost inode.
<P>
<A HREF="http://localhost/cgi-bin/man/man2html?2+statfs">statfs</A>(2) returns the information of the first branch info except
namelen when [oq]nosum[cq] is specified (the default). The namelen is
decreased by the whiteout prefix length. And the block size may differ
from st_blksize which is obtained by <A HREF="http://localhost/cgi-bin/man/man2html?2+stat">stat</A>(2).
<P>
Remember, <A HREF="http://localhost/cgi-bin/man/man2html?3+seekdir">seekdir</A>(3) and <A HREF="http://localhost/cgi-bin/man/man2html?3+telldir">telldir</A>(3) are not defined in POSIX. They may
not work as you expect. Try <A HREF="http://localhost/cgi-bin/man/man2html?3+rewinddir">rewinddir</A>(3) or re-open the dir.
<P>
The whiteout prefix (AUFS_WH_PFX]) is reserved on all branches. Users should
not handle the filename begins with this prefix.
In order to future whiteout, the maximum filename length is limited by
the longest value - AUFS_WH_PFX_LEN]. It may be a violation of POSIX.
<P>
If you dislike the difference between the aufs entries in /etc/mtab
and /proc/mounts, and if you are using <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) in util-linux package,
then try ./mount.aufs utility. Copy the script to /sbin/mount.aufs.
This simple utility tries updating
/etc/mtab. If you do not care about /etc/mtab, you can ignore this
utility.
Remember this utility is highly depending upon <A HREF="http://localhost/cgi-bin/man/man2html?8+mount">mount</A>(8) in
util-linux-2.12p package, and you need to mount /proc.
<P>
Since aufs uses its own inode and dentry, your system may cache huge
number of inodes and dentries. It can be as twice as all of the files
in your union.
It means that unmounting or remounting readonly at shutdown time may
take a long time, since <A HREF="http://localhost/cgi-bin/man/man2html?2+mount">mount</A>(2) in VFS tries freeing all of the cache
on the target filesystem.
<P>
When you open a directory, aufs will open several directories
internally.
It means you may reach the limit of the number of file descriptor.
And when the lower directory cannot be opened, aufs will close all the
opened upper directories and return an error.
<P>
The sub-mount under the branch
of local filesystem
is ignored.
For example, if you have mount another filesystem on
/branch/another/mntpnt, the files under [oq]mntpnt[cq] will be ignored by aufs.
It is recommended to mount the sub-mount under the mounted aufs.
For example,
<P>
<PRE>
# sudo mount /dev/sdaXX /ro_branch
# d=another/mntpnt
# sudo mount /dev/sdbXX /ro_branch/$d
# mkdir -p /rw_branch/$d
# sudo mount -t aufs -o br:/rw_branch:/ro_branch none /aufs
# sudo mount -t aufs -o br:/rw_branch/${d}:/ro_branch/${d} none /aufs/another/$d
</PRE>

<P>
There are several characters which are not allowed to use in a branch
directory path and xino filename. See detail in Branch Syntax and Mount
Option.
<P>
The file-lock which means <A HREF="http://localhost/cgi-bin/man/man2html?2+fcntl">fcntl</A>(2) with F_SETLK, F_SETLKW or F_GETLK, <A HREF="http://localhost/cgi-bin/man/man2html?2+flock">flock</A>(2)
and <A HREF="http://localhost/cgi-bin/man/man2html?3+lockf">lockf</A>(3), is applied to virtual aufs file only, not to the file on a
branch. It means you can break the lock by accessing a branch directly.
TODO: check [oq]security[cq] to hook locks, as inotify does.
<P>
The I/O to the named pipe or local socket are not handled by aufs, even
if it exists in aufs. After the reader and the writer established their
connection if the pipe/socket are copied-up, they keep using the old one
instead of the copied-up one.
<P>
The <A HREF="http://localhost/cgi-bin/man/man2html?2+fsync">fsync</A>(2) and <A HREF="http://localhost/cgi-bin/man/man2html?2+fdatasync">fdatasync</A>(2) systemcalls return 0 which means success, even
if the given file descriptor is not opened for writing.
I am afraid this behaviour may violate some standards. Checking the
behaviour of <A HREF="http://localhost/cgi-bin/man/man2html?2+fsync">fsync</A>(2) on ext2, aufs decided to return success.
<P>
If you want to use disk-quota, you should set it up to your writable
branch since aufs does not have its own block device.
<P>
When your aufs is the root directory of your system, and your system
tells you some of the filesystem were not unmounted cleanly, try these
procedure when you shutdown your system.
<PRE>
# mount -no remount,ro /
# for i in $writable_branches
# do mount -no remount,ro $i
# done
</PRE>

If your xino file is on a hard drive, you also need to specify
[oq]noxino[cq] option or [oq]xino=/your/tmpfs/xino[cq] at remounting root
directory.
<P>
To <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) directory may return EXDEV even if both of src and tgt
are on the same aufs. When the rename-src dir exists on multiple
branches and the lower dir has child(ren), aufs has to copyup all his
children. It can be recursive copyup. Current aufs does not support
such huge copyup operation at one time in kernel space, instead
produces a warning and returns EXDEV.
Generally, <A HREF="http://localhost/cgi-bin/man/man2html?1+mv">mv</A>(1) detects this error and tries <A HREF="http://localhost/cgi-bin/man/man2html?2+mkdir">mkdir</A>(2) and
<A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) or copy/unlink recursively. So the result is harmless.
If your application which issues <A HREF="http://localhost/cgi-bin/man/man2html?2+rename">rename</A>(2) for a directory does not
support EXDEV, it will not work on aufs.
Also this specification is applied to the case when the src directory
exists on the lower readonly branch and it has child(ren).
<P>
If a sudden accident such like a power failure happens during aufs is
performing, and regular fsck for branch filesystems is completed after
the disaster, you need to extra fsck for aufs writable branches. It is
necessary to check whether the whiteout remains incorrectly or not,
eg. the real filename and the whiteout for it under the same parent
directory. If such whiteout remains, aufs cannot handle the file
correctly.
To check the consistency from the aufs[aq] point of view, you can use a
simple shell script called /sbin/auchk. Its purpose is a fsck tool for
aufs, and it checks the illegal whiteout, the remained
pseudo-links and the remained aufs-temp files. If they are found, the
utility reports you and asks whether to delete or not.
It is recommended to execute /sbin/auchk for every writable branch
filesystem before mounting aufs if the system experienced crash.
<P>
<P>

<A NAME="lbBE">&nbsp;</A>
<H2>EXAMPLES</H2>

The mount options are interpreted from left to right at remount-time.
These examples
shows how the options are handled. (assuming /sbin/mount.aufs was
installed)
<P>
<PRE>
# mount -v -t aufs br:/day0:/base none /u
none on /u type aufs (rw,xino=/day0/.aufs.xino,br:/day0=rw:/base=ro)
# mount -v -o remount,\
        prepend:/day1,\
        xino=/day1/xino,\
        mod:/day0=ro,\
        del:/day0 \
        /u
none on /u type aufs (rw,xino=/day1/xino,br:/day1=rw:/base=ro)
</PRE>

<P>
<PRE>
# mount -t aufs br:/rw none /u
# mount -o remount,append:/ro /u
different uid/gid/permission, /ro
# mount -o remount,del:/ro /u
# mount -o remount,nowarn_perm,append:/ro /u
#
(there is no warning)
</PRE>

<P>



























<P>
When you use aufs as root filesystem, it is recommended to consider to
exclude some directories. For example, /tmp and /var/log are not need
to stack in many cases. They do not usually need to copyup or to whiteout.
Also the swapfile on aufs (a regular file, not a block device) is not
supported.
In order to exclude the specific dir from aufs, try bind mounting.
<P>
And there is a good sample which is for network booted diskless machines. See
sample/ in detail.
<P>

<A NAME="lbBF">&nbsp;</A>
<H2>DIAGNOSTICS</H2>

When you add a branch to your union, aufs may warn you about the
privilege or security of the branch, which is the permission bits,
owner and group of the top directory of the branch.
For example, when your upper writable branch has a world writable top
directory,
a malicious user can create any files on the writable branch directly,
like copyup and modify manually. I am afraid it can be a security
issue.
<P>
When you mount or remount your union without -o ro common mount option
and without writable branch, aufs will warn you that the first branch
should be writable.
<P>




<P>
When you set udba other than inotify and change something on your
branch filesystem directly, later aufs may detect some mismatches to
its cache. If it is a critical mismatch, aufs returns EIO.
<P>
When an error occurs in aufs, aufs prints the kernel message with
[oq]errno.[cq] The priority of the message (log level) is ERR or WARNING which
depends upon the message itself.
You can convert the [oq]errno[cq] into the error message by <A HREF="http://localhost/cgi-bin/man/man2html?3+perror">perror</A>(3),
<A HREF="http://localhost/cgi-bin/man/man2html?3+strerror">strerror</A>(3) or something.
For example, the [oq]errno[cq] in the message [oq]I/O Error, write failed (-28)[cq]
is 28 which means ENOSPC or [oq]No space left on device.[cq]
<P>
When CONFIG_AUFS_BR_RAMFS is enabled, you can specify ramfs as an aufs
branch. Since ramfs is simple, it does not set the maximum link count
originally. In aufs, it is very dangerous, particularly for
whiteouts. Finally aufs sets the maximum link count for ramfs. The
value is 32000 which is borrowed from ext2.
<P>
<P>



















































<P>
<A NAME="lbBG">&nbsp;</A>
<H2>COPYRIGHT</H2>

Copyright &#169; 2005-2009 Junjiro R. Okajima
<P>
<A NAME="lbBH">&nbsp;</A>
<H2>AUTHOR</H2>

Junjiro R. Okajima
<P>



<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DT><A HREF="#lbAD">MOUNT OPTIONS</A><DD>
<DT><A HREF="#lbAE">Module Parameters</A><DD>
<DT><A HREF="#lbAF">Entries under Sysfs and Debugfs</A><DD>
<DT><A HREF="#lbAG">Branch Syntax</A><DD>
<DL>
<DT><A HREF="#lbAH">Permission</A><DD>
<DT><A HREF="#lbAI">Attribute</A><DD>
</DL>
<DT><A HREF="#lbAJ">External Inode Number Bitmap, Translation Table and Generation Table (xino)</A><DD>
<DT><A HREF="#lbAK">Pseudo Link (hardlink over branches)</A><DD>
<DL>
<DT><A HREF="#lbAL">The behaviours of plink and noplink</A><DD>
</DL>
<DT><A HREF="#lbAM">User[aq]s Direct Branch Access (UDBA)</A><DD>
<DT><A HREF="#lbAN">Linux Inotify Limitation</A><DD>
<DL>
<DT><A HREF="#lbAO">IN_ATTRIB, updating atime</A><DD>
<DT><A HREF="#lbAP">IN_ATTRIB, updating nlink</A><DD>
<DT><A HREF="#lbAQ">IN_DELETE, removing file on NFS</A><DD>
<DT><A HREF="#lbAR">IN_IGNORED, deleted rename target</A><DD>
</DL>
<DT><A HREF="#lbAS">Virtual or Vertical Directory Block (VDIR)</A><DD>
<DT><A HREF="#lbAT">VDIR/readdir(3) in user-space (RDU)</A><DD>
<DL>
<DT><A HREF="#lbAU">Note</A><DD>
</DL>
<DT><A HREF="#lbAV">Copy On Write, or aufs internal copyup and copydown</A><DD>
<DT><A HREF="#lbAW">Policies to Select One among Multiple Writable Branches</A><DD>
<DL>
<DT><A HREF="#lbAX">Exceptions for Policies</A><DD>
<DT><A HREF="#lbAY">Policies for Creating</A><DD>
<DT><A HREF="#lbAZ">Policies for Copy-Up</A><DD>
</DL>
<DT><A HREF="#lbBA">Exporting Aufs via NFS</A><DD>
<DT><A HREF="#lbBB">Dentry and Inode Caches</A><DD>
<DT><A HREF="#lbBC">Compatible/Incompatible with Unionfs Version 1.x Series</A><DD>
<DT><A HREF="#lbBD">Incompatible with an Ordinary Filesystem</A><DD>
<DT><A HREF="#lbBE">EXAMPLES</A><DD>
<DT><A HREF="#lbBF">DIAGNOSTICS</A><DD>
<DT><A HREF="#lbBG">COPYRIGHT</A><DD>
<DT><A HREF="#lbBH">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 09:43:00 GMT, September 04, 2009
</BODY>
</HTML>
